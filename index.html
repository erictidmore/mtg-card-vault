<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Card Vault</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: #e2e8f0;
            --accent: #8b5cf6;
            --accent-light: #c4b5fd;
            --accent-rgb: 139,92,246;
            --accent-light-rgb: 196,181,253;
            --panel-rgb: 120,100,180;
            --bg: #0a0a0f;
            transition: background-color 0.6s ease;
        }

        h1, h2, h3, button {
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Glass Panels */
        .clean-panel {
            background: rgba(20, 20, 35, 0.7);
            border: 1px solid rgba(120, 100, 180, 0.15);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        /* Input Fields */
        input[type="text"], select, textarea, input[type="range"] {
            background: rgba(15, 15, 25, 0.8) !important;
            border: 1px solid rgba(120, 100, 180, 0.2) !important;
            color: #e2e8f0 !important;
            font-family: 'Share Tech Mono', monospace;
            transition: all 0.2s ease;
        }
        input[type="text"]:focus, select:focus, textarea:focus {
            border-color: #8b5cf6 !important;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.15);
            outline: none;
        }
        input[type="text"]::placeholder, textarea::placeholder {
            color: #64748b !important;
        }
        select option {
            background: #1a1a2e;
            color: #e2e8f0;
        }

        /* Cards */
        .card {
            background: rgba(20, 20, 35, 0.7);
            border: 1px solid rgba(120, 100, 180, 0.15);
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
        }

        /* Buttons */
        .btn-clean {
            transition: all 0.2s;
            font-weight: 600;
        }
        .btn-clean:hover {
            filter: brightness(1.1);
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 15, 0.5);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 92, 246, 0.5);
        }

        /* Loader */
        .loader {
            border-top-color: #8b5cf6;
            border-right-color: #c4b5fd;
            border-bottom-color: #8b5cf6;
            border-left-color: #c4b5fd;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Quantity Buttons - touch targets */
        .quantity-btn {
            min-width: 28px;
            min-height: 28px;
        }
        @media (max-width: 639px) {
            .quantity-btn {
                min-width: 36px;
                min-height: 36px;
            }
        }

        /* Checklist View */
        .checklist-container {
            column-width: 280px;
            column-gap: 2rem;
            width: 100%;
        }
        .checklist-item {
            break-inside: avoid;
            page-break-inside: avoid;
            display: flex;
            align-items: center;
            border-bottom: 1px dotted rgba(120, 100, 180, 0.2);
            padding: 6px 0;
            font-family: 'Share Tech Mono', monospace;
            color: #94a3b8;
            transition: color 0.2s;
        }
        .checklist-item:hover {
            background-color: rgba(139, 92, 246, 0.06);
            color: #e2e8f0;
        }

        .modal-overlay {
            background: rgba(5, 5, 10, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* Manifest Studio — stays LIGHT for PNG export */
        #photo-viewport {
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: #3a3a4a;
            height: 100%;
            width: 100%;
            padding: 40px;
        }

        #photo-stage {
            width: 1200px;
            max-width: 100%;
            background: #ffffff;
            color: #0f172a;
            position: relative;
            padding: 0;
            box-sizing: border-box;
            box-shadow: 0 4px 30px rgba(0,0,0,0.4);
            margin: 0 auto;
            min-height: 800px;
            font-family: 'Inter', sans-serif;
        }
        @media (max-width: 639px) {
            #photo-viewport {
                padding: 12px;
            }
        }

        .manifest-header {
            background: #f1f5f9;
            border-bottom: 4px solid #334155;
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .manifest-highlights {
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            width: 100%;
        }

        .highlight-card {
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .highlight-img-container {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            overflow: hidden;
            border-radius: 4px;
            margin-bottom: 8px;
            background: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .highlight-img-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .manifest-list-container {
            padding: 40px;
            column-count: 3;
            column-gap: 40px;
            column-rule: 1px solid #e2e8f0;
        }
        @media (max-width: 900px) {
            .manifest-list-container {
                column-count: 2;
                padding: 24px;
                column-gap: 24px;
            }
            .highlight-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            .manifest-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
                padding: 20px 24px;
            }
            .manifest-header > div:last-child {
                text-align: left;
            }
            .manifest-highlights {
                padding: 20px 24px;
            }
        }
        @media (max-width: 500px) {
            .manifest-list-container {
                column-count: 1;
                padding: 16px;
            }
            .highlight-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .manifest-row {
            break-inside: avoid;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            border-bottom: 1px dotted #cbd5e1;
            padding: 3px 0;
            font-size: 13px;
            line-height: 1.4;
        }

        .manifest-row:last-child {
            border-bottom: none;
        }

        /* Range Slider Styling */
        input[type=range] {
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(120, 100, 180, 0.3);
            border-radius: 2px;
        }

        /* Checkbox styling */
        input[type="checkbox"] {
            accent-color: #8b5cf6;
        }

        /* Autocomplete */
        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(120, 100, 180, 0.3);
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 240px;
            overflow-y: auto;
            z-index: 30;
            backdrop-filter: blur(16px);
        }
        .autocomplete-dropdown .ac-item {
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
            font-size: 13px;
            color: #c4b5fd;
            transition: background 0.15s;
        }
        .autocomplete-dropdown .ac-item:hover {
            background: rgba(139, 92, 246, 0.15);
        }

        /* Advanced Filters */
        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 12px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Inter', sans-serif;
        }
        .color-btn.active {
            border-color: #8b5cf6;
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
            transform: scale(1.15);
        }

        /* Card Flip */
        .card-flip-container {
            perspective: 800px;
        }
        .card-flip-inner {
            position: relative;
            width: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .card-flip-inner.flipped {
            transform: rotateY(180deg);
        }
        .card-flip-front, .card-flip-back {
            backface-visibility: hidden;
        }
        .card-flip-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            transform: rotateY(180deg);
        }
        .flip-icon {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.65);
            color: #c4b5fd;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            cursor: pointer;
            z-index: 5;
            backdrop-filter: blur(4px);
            transition: background 0.2s;
        }
        .flip-icon:hover {
            background: rgba(139, 92, 246, 0.6);
        }

        /* Export Dropdown */
        .export-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(120, 100, 180, 0.3);
            border-radius: 8px;
            overflow: hidden;
            z-index: 40;
            margin-bottom: 4px;
            backdrop-filter: blur(16px);
        }
        .export-dropdown button {
            display: block;
            width: 100%;
            padding: 6px 12px;
            text-align: left;
            color: #c4b5fd;
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            background: none;
            border: none;
            cursor: pointer;
            transition: background 0.15s;
        }
        .export-dropdown button:hover {
            background: rgba(139, 92, 246, 0.15);
        }

        /* Format Badges */
        .fmt-badge {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: 700;
            font-family: 'Share Tech Mono', monospace;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.2);
            margin-right: 2px;
            line-height: 1.2;
        }

        /* Stat Bars */
        .stat-bar-container { margin-bottom: 6px; }
        .stat-bar-label {
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            color: #94a3b8;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }
        .stat-bar-track {
            height: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            overflow: hidden;
        }
        .stat-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.4s ease;
        }

        /* Inline Quantity */
        .inline-qty {
            width: 40px;
            text-align: center;
            background: rgba(15, 15, 25, 0.8) !important;
            border: 1px solid rgba(120, 100, 180, 0.2) !important;
            border-radius: 6px;
            color: #e2e8f0 !important;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            padding: 2px;
            -moz-appearance: textfield;
        }
        .inline-qty::-webkit-inner-spin-button,
        .inline-qty::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Mana Symbols */
        .mana-symbol {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 11px;
            font-weight: 700;
            margin-right: 2px;
        }

        /* Wishlist Styling */
        .wishlist-item {
            opacity: 0.7;
            border-style: dashed !important;
        }

        /* ===== MANA THEME SYSTEM ===== */
        .mana-orb {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        .mana-orb:hover {
            transform: scale(1.25);
            border-color: rgba(255,255,255,0.4);
        }
        .mana-orb.active {
            border-color: var(--accent-light);
            box-shadow: 0 0 14px 3px rgba(var(--accent-rgb), 0.5);
            transform: scale(1.15);
        }

        /* Theme overrides — cascade over hardcoded values */
        .clean-panel { border-color: rgba(var(--panel-rgb), 0.15) !important; }
        .card { border-color: rgba(var(--panel-rgb), 0.15) !important; }
        .card:hover { box-shadow: 0 4px 20px rgba(var(--accent-rgb), 0.2) !important; border-color: rgba(var(--accent-rgb), 0.4) !important; }
        input[type="text"]:focus, select:focus, textarea:focus, input[type="number"]:focus { border-color: var(--accent) !important; box-shadow: 0 0 0 3px rgba(var(--accent-rgb), 0.15) !important; }
        input[type="text"], select, textarea, input[type="range"] { border-color: rgba(var(--panel-rgb), 0.2) !important; }
        ::-webkit-scrollbar-thumb { background: rgba(var(--accent-rgb), 0.3) !important; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(var(--accent-rgb), 0.5) !important; }
        .loader { border-top-color: var(--accent) !important; border-right-color: var(--accent-light) !important; border-bottom-color: var(--accent) !important; border-left-color: var(--accent-light) !important; }
        input[type=range]::-webkit-slider-thumb { background: var(--accent) !important; }
        input[type=range]::-webkit-slider-runnable-track { background: rgba(var(--panel-rgb), 0.3) !important; }
        input[type="checkbox"] { accent-color: var(--accent) !important; }
        .checklist-item { border-bottom-color: rgba(var(--panel-rgb), 0.2) !important; }
        .checklist-item:hover { background-color: rgba(var(--accent-rgb), 0.06) !important; }
        .color-btn.active { border-color: var(--accent) !important; box-shadow: 0 0 8px rgba(var(--accent-rgb), 0.5) !important; }
        .flip-icon { color: var(--accent-light) !important; }
        .flip-icon:hover { background: rgba(var(--accent-rgb), 0.6) !important; }
        .autocomplete-dropdown { border-color: rgba(var(--panel-rgb), 0.3) !important; }
        .autocomplete-dropdown .ac-item { color: var(--accent-light) !important; }
        .autocomplete-dropdown .ac-item:hover { background: rgba(var(--accent-rgb), 0.15) !important; }
        .export-dropdown { border-color: rgba(var(--panel-rgb), 0.3) !important; }
        .export-dropdown button { color: var(--accent-light) !important; }
        .export-dropdown button:hover { background: rgba(var(--accent-rgb), 0.15) !important; }
        .fmt-badge { background: rgba(var(--accent-rgb), 0.15) !important; color: var(--accent-light) !important; border-color: rgba(var(--accent-rgb), 0.2) !important; }
        .inline-qty { border-color: rgba(var(--panel-rgb), 0.2) !important; }

        /* Tailwind utility overrides */
        .bg-purple-600 { background-color: var(--accent) !important; }
        .hover\:bg-purple-500:hover { background-color: var(--accent) !important; filter: brightness(1.15) !important; }
        .text-purple-400 { color: var(--accent-light) !important; }
        .text-purple-300 { color: var(--accent-light) !important; }
        .border-t-purple-500 { border-top-color: var(--accent) !important; }
        .border-purple-500\/30 { border-color: rgba(var(--accent-rgb), 0.3) !important; }
        .border-purple-500\/20 { border-color: rgba(var(--accent-rgb), 0.2) !important; }
        .bg-purple-500\/10 { background-color: rgba(var(--accent-rgb), 0.1) !important; }
        .bg-purple-600\/30 { background-color: rgba(var(--accent-rgb), 0.3) !important; }
        .hover\:bg-purple-500\/20:hover { background-color: rgba(var(--accent-rgb), 0.2) !important; }
        .hover\:text-purple-400:hover { color: var(--accent-light) !important; }
        .hover\:border-purple-500\/40:hover { border-color: rgba(var(--accent-rgb), 0.4) !important; }
        .bg-purple-500 { background-color: var(--accent) !important; }

        /* Light mode toggle */
        .light-toggle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            flex-shrink: 0;
            line-height: 1;
        }
        .light-toggle:hover {
            transform: scale(1.2);
            border-color: rgba(255,255,255,0.4);
        }
        body.light-mode .light-toggle {
            border-color: rgba(0,0,0,0.15);
            background: rgba(0,0,0,0.05);
        }
        body.light-mode .light-toggle:hover {
            border-color: rgba(0,0,0,0.3);
        }

        /* ===== LIGHT MODE ===== */
        body.light-mode {
            color: #1e293b;
            transition: background-color 0.6s ease, color 0.4s ease;
        }

        /* Panels & Cards */
        body.light-mode .clean-panel {
            background: rgba(255, 255, 255, 0.75) !important;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06) !important;
        }
        body.light-mode .card {
            background: rgba(255, 255, 255, 0.8) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06) !important;
        }

        /* Inputs */
        body.light-mode input[type="text"],
        body.light-mode input[type="number"],
        body.light-mode select,
        body.light-mode textarea {
            background: rgba(255, 255, 255, 0.9) !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
            color: #1e293b !important;
        }
        body.light-mode input[type="text"]::placeholder,
        body.light-mode textarea::placeholder {
            color: #94a3b8 !important;
        }
        body.light-mode select option {
            background: #fff;
            color: #1e293b;
        }
        body.light-mode .inline-qty {
            background: rgba(255,255,255,0.9) !important;
            border-color: rgba(0,0,0,0.12) !important;
            color: #1e293b !important;
        }

        /* Scrollbar */
        body.light-mode ::-webkit-scrollbar-track { background: rgba(0,0,0,0.03) !important; }

        /* Modals */
        body.light-mode .modal-overlay { background: rgba(0, 0, 0, 0.25) !important; }
        body.light-mode #importModal > div,
        body.light-mode #visualViewContent,
        body.light-mode #ebayViewModal > div,
        body.light-mode #cardDetailModal > div,
        body.light-mode #statsModal > div,
        body.light-mode #dupesModal > div {
            background: rgba(255, 255, 255, 0.95) !important;
        }
        body.light-mode #photoStudioModal > div {
            background: rgba(245, 245, 240, 0.98) !important;
        }

        /* Checklist */
        body.light-mode .checklist-item { border-bottom-color: rgba(0,0,0,0.08) !important; color: #475569; }
        body.light-mode .checklist-item:hover { background-color: rgba(var(--accent-rgb), 0.06) !important; color: #1e293b; }

        /* Text color flips */
        body.light-mode .text-slate-100 { color: #1e293b !important; }
        body.light-mode .text-slate-200 { color: #334155 !important; }
        body.light-mode .text-slate-300 { color: #475569 !important; }
        body.light-mode .text-slate-400 { color: #64748b !important; }
        body.light-mode .text-slate-500 { color: #94a3b8 !important; }
        body.light-mode .text-slate-600 { color: #94a3b8 !important; }

        /* Background utility flips */
        body.light-mode .bg-white\/5 { background-color: rgba(0,0,0,0.03) !important; }
        body.light-mode .bg-white\/10 { background-color: rgba(0,0,0,0.05) !important; }
        body.light-mode .hover\:bg-white\/10:hover { background-color: rgba(0,0,0,0.07) !important; }

        /* Border flips */
        body.light-mode .border-white\/10 { border-color: rgba(0,0,0,0.08) !important; }
        body.light-mode .border-t-white\/10 { border-top-color: rgba(0,0,0,0.08) !important; }
        body.light-mode .border-white\/5 { border-color: rgba(0,0,0,0.05) !important; }

        /* Mana orbs in light mode */
        body.light-mode .mana-orb { border-color: rgba(0,0,0,0.12); }
        body.light-mode .mana-orb:hover { border-color: rgba(0,0,0,0.3); }

        /* Autocomplete & dropdowns */
        body.light-mode .autocomplete-dropdown { background: rgba(255,255,255,0.97) !important; }
        body.light-mode .autocomplete-dropdown .ac-item { color: #475569 !important; }
        body.light-mode .autocomplete-dropdown .ac-item:hover { background: rgba(var(--accent-rgb), 0.08) !important; }
        body.light-mode .export-dropdown { background: rgba(255,255,255,0.97) !important; }
        body.light-mode .export-dropdown button { color: #475569 !important; }
        body.light-mode .export-dropdown button:hover { background: rgba(var(--accent-rgb), 0.08) !important; }

        /* Ebay view body */
        body.light-mode #ebay-view-body { background: rgba(0,0,0,0.02) !important; }

        /* Stat bars */
        body.light-mode .stat-bar-track { background: rgba(0,0,0,0.06) !important; }
        body.light-mode .stat-bar-label { color: #64748b !important; }
    </style>
</head>
<body class="min-h-screen">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-6 sm:mb-10 relative">
            <h1 class="text-3xl sm:text-5xl md:text-6xl font-bold text-slate-100 tracking-tight">MTG Card Vault</h1>
            <p class="text-purple-400 mt-2 font-mono text-sm tracking-widest">COLLECTION MANAGER</p>
            <div class="flex justify-center items-center gap-3 mt-3">
                <button class="mana-orb" data-theme="white" style="background: radial-gradient(circle at 35% 35%, #E8DCCA, #B09470);" title="Plains"></button>
                <button class="mana-orb" data-theme="blue" style="background: radial-gradient(circle at 35% 35%, #5DADE2, #0E68AB);" title="Island"></button>
                <button class="mana-orb" data-theme="black" style="background: radial-gradient(circle at 35% 35%, #555, #150B00);" title="Swamp"></button>
                <button class="mana-orb" data-theme="red" style="background: radial-gradient(circle at 35% 35%, #F1948A, #C0392B);" title="Mountain"></button>
                <button class="mana-orb" data-theme="green" style="background: radial-gradient(circle at 35% 35%, #58D68D, #00733E);" title="Forest"></button>
                <span class="text-slate-600 mx-1">|</span>
                <button id="lightModeToggle" class="light-toggle" title="Toggle light/dark mode">☀</button>
            </div>
            <p class="text-slate-600 mt-2 font-mono text-[10px] tracking-wider">CTRL+Z UNDO · CTRL+SHIFT+Z REDO · CTRL+S SAVE · ESC CLOSE · ←→ PAGINATE</p>
        </header>

        <div class="mb-6 sm:mb-8 p-4 sm:p-6 rounded-2xl clean-panel relative">
            <h2 class="text-2xl font-bold mb-4 text-slate-100 flex items-center">
                <span class="inline-block w-1 h-6 bg-purple-500 mr-3 rounded-sm"></span>
                Card Search
            </h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="setCode" class="flex-grow rounded-xl px-4 py-3" placeholder="Enter set codes (e.g. LTR, MOM)">
                <button id="searchBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-8 rounded-xl">SEARCH</button>
                <button id="clearSearchBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-8 rounded-xl border border-white/10">CLEAR</button>
            </div>
            <div class="relative mt-4">
                <input type="text" id="cardNameSearch" class="w-full rounded-xl px-4 py-3" placeholder="Search by card name (autocomplete)...">
                <div id="autocompleteDropdown" class="autocomplete-dropdown hidden"></div>
            </div>
            <div class="flex flex-col sm:flex-row gap-x-8 gap-y-4 mt-5 text-sm font-medium">
                <div class="flex items-center group cursor-pointer">
                    <input type="checkbox" id="includeDigital" class="h-4 w-4 border-slate-300 rounded text-blue-600 focus:ring-blue-500/50 cursor-pointer">
                    <label for="includeDigital" class="ml-2 text-slate-400 group-hover:text-slate-200 transition-colors cursor-pointer">Include Digital</label>
                </div>
                <div class="flex items-center">
                    <label for="uniquenessFilter" class="mr-3 text-slate-400">Filter:</label>
                    <select id="uniquenessFilter" class="rounded-xl px-3 py-1 text-sm">
                        <option value="prints">All Prints</option>
                        <option value="cards">Base Set</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="loader" class="hidden justify-center items-center my-8">
            <div class="loader ease-linear rounded-full border-4 h-24 w-24"></div>
        </div>
        <div id="message-area" class="text-center font-mono text-purple-300 my-4 h-6 text-sm tracking-wide"></div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-2 order-2 lg:order-1">
                <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
                    <h2 class="text-3xl font-bold text-slate-100 flex items-center">
                        Results
                    </h2>
                    <div class="flex flex-col sm:flex-row gap-4 items-center w-full md:w-auto">
                         <button id="toggleFiltersBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-4 rounded-xl text-xs border border-white/10">FILTERS</button>
                         <input type="text" id="filterInput" class="rounded-xl px-4 py-2 w-full sm:w-64" placeholder="Filter by Name">
                        <select id="sortOrder" class="rounded-xl px-2 py-2 w-full sm:w-auto">
                            <option value="name_asc">Name (A-Z)</option>
                            <option value="name_desc">Name (Z-A)</option>
                            <option value="price_desc">Price (High)</option>
                            <option value="price_asc">Price (Low)</option>
                        </select>
                    </div>
                </div>
                <div id="advancedFilters" class="hidden mb-6 p-4 rounded-xl clean-panel">
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div>
                            <label class="text-xs text-slate-500 font-mono mb-1 block">RARITY</label>
                            <select id="filterRarity" class="rounded-xl px-2 py-2 w-full">
                                <option value="">Any</option>
                                <option value="common">Common</option>
                                <option value="uncommon">Uncommon</option>
                                <option value="rare">Rare</option>
                                <option value="mythic">Mythic</option>
                            </select>
                        </div>
                        <div>
                            <label class="text-xs text-slate-500 font-mono mb-1 block">TYPE</label>
                            <select id="filterType" class="rounded-xl px-2 py-2 w-full">
                                <option value="">Any</option>
                                <option value="creature">Creature</option>
                                <option value="instant">Instant</option>
                                <option value="sorcery">Sorcery</option>
                                <option value="enchantment">Enchantment</option>
                                <option value="artifact">Artifact</option>
                                <option value="planeswalker">Planeswalker</option>
                                <option value="land">Land</option>
                            </select>
                        </div>
                        <div>
                            <label class="text-xs text-slate-500 font-mono mb-1 block">CMC MIN</label>
                            <input type="text" id="filterCmcMin" class="rounded-xl px-2 py-2 w-full" placeholder="0">
                        </div>
                        <div>
                            <label class="text-xs text-slate-500 font-mono mb-1 block">CMC MAX</label>
                            <input type="text" id="filterCmcMax" class="rounded-xl px-2 py-2 w-full" placeholder="any">
                        </div>
                    </div>
                    <div class="mt-4">
                        <label class="text-xs text-slate-500 font-mono mb-2 block">COLOR IDENTITY</label>
                        <div class="flex gap-2">
                            <button class="color-btn" data-color="W" style="background:#F9FAF4;color:#333;">W</button>
                            <button class="color-btn" data-color="U" style="background:#0E68AB;color:#fff;">U</button>
                            <button class="color-btn" data-color="B" style="background:#150B00;color:#fff;">B</button>
                            <button class="color-btn" data-color="R" style="background:#D3202A;color:#fff;">R</button>
                            <button class="color-btn" data-color="G" style="background:#00733E;color:#fff;">G</button>
                        </div>
                    </div>
                </div>
                <div id="searchResults" class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
                    </div>
                <div id="paginationControls" class="mt-8 flex justify-center items-center gap-6 hidden">
                    <button id="prevPageBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 border border-white/10 font-bold py-2 px-6 rounded-xl transition">PREV</button>
                    <span id="pageInfo" class="text-lg font-mono text-slate-400"></span>
                    <button id="nextPageBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 border border-white/10 font-bold py-2 px-6 rounded-xl transition">NEXT</button>
                </div>
            </div>

            <div class="order-1 lg:order-2">
                <div class="lg:sticky top-8">
                    <div class="clean-panel rounded-2xl p-6 border-t-4 border-t-purple-500">
                        <div class="mb-6">
                            <h2 class="text-2xl font-bold text-slate-100 mb-4 flex items-center justify-between">
                                Collection
                                <span class="text-xs font-mono text-purple-300 border border-purple-500/30 px-2 py-1 rounded bg-purple-500/10">Active</span>
                            </h2>
                            <div class="flex flex-col sm:flex-row gap-2 mb-2">
                                <select id="collectionSelector" class="flex-grow rounded-xl px-2 py-2"></select>
                                <select id="currency" class="rounded-xl px-2 py-2 mt-2 sm:mt-0 w-24">
                                    <option value="usd">USD</option>
                                    <option value="eur">EUR</option>
                                    <option value="tix">TIX</option>
                                </select>
                            </div>
                             <div class="flex flex-col gap-2">
                                <input type="text" id="newCollectionName" class="w-full rounded-xl px-4 py-2" placeholder="New collection name...">
                                <div class="flex gap-2">
                                    <select id="collectionTypeSelector" class="rounded-xl px-2 py-2 w-28 text-xs">
                                        <option value="collection">Collection</option>
                                        <option value="wishlist">Wishlist</option>
                                    </select>
                                    <button id="createCollectionBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 rounded-xl text-sm flex-1">CREATE</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-3 sm:grid-cols-3 gap-2 mt-4">
                                <button id="renameCollectionBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">RENAME</button>
                                <button id="updatePricesBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">SYNC</button>
                                <button id="importTxtBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">IMPORT</button>
                                <button id="statsBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">STATS</button>
                                <button id="dupesBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">DUPES</button>
                                <div class="relative">
                                    <button id="exportTxtBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap w-full h-full">EXPORT ▼</button>
                                    <div id="exportDropdown" class="export-dropdown hidden">
                                        <button data-format="txt">TXT (Original)</button>
                                        <button data-format="moxfield">Moxfield</button>
                                        <button data-format="archidekt">Archidekt</button>
                                        <button data-format="csv">CSV</button>
                                        <button data-format="share">Share Link</button>
                                    </div>
                                </div>
                                <button id="visualViewBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">GRID VIEW</button>
                                <button id="photoStudioBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">MANIFEST</button>
                                <button id="legalityBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">LEGALITY</button>
                                <button id="ebayViewBtn" class="col-span-3 btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-xl text-xs border border-purple-500/30 whitespace-nowrap">LIST GENERATOR</button>
                            </div>
                        </div>

                        <div class="bg-white/5 rounded-xl p-4 border border-white/10 mb-4 font-mono">
                            <div class="flex justify-between items-center mb-1">
                                <p class="text-slate-500 text-xs">TOTAL VALUE</p>
                                <p id="totalValue" class="text-xl font-bold text-green-400">$0.00</p>
                            </div>
                            <div class="flex justify-between items-center">
                                <p class="text-slate-500 text-xs">TOTAL CARDS</p>
                                <p id="totalCards" class="text-xl font-bold text-slate-200">0</p>
                            </div>
                        </div>

                        <div id="priceChartContainer" class="mb-4 hidden">
                            <p class="text-slate-500 text-[10px] font-mono mb-1 tracking-wider">PRICE HISTORY</p>
                            <canvas id="priceHistoryChart" height="100"></canvas>
                        </div>

                        <div id="inventory" class="space-y-3 max-h-[50vh] lg:max-h-[40vh] overflow-y-auto pr-2">
                            </div>

                        <div class="mt-6 pt-4 border-t border-white/10 flex flex-col sm:flex-row gap-4">
                            <button id="saveCollectionsBtn" class="flex-1 btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 rounded-xl text-xs">SAVE</button>
                            <button id="deleteCollectionBtn" class="flex-1 btn-clean bg-white/5 hover:bg-red-500/20 text-red-400 font-bold py-2 px-4 rounded-xl text-xs border border-red-500/20">DELETE</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="importModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-5 sm:p-8 w-full max-w-2xl border border-white/10 shadow-2xl max-h-[95vh] overflow-y-auto" style="background: rgba(20, 20, 35, 0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <h2 class="text-2xl font-bold mb-2 text-slate-100">Import Cards</h2>
            <p class="text-slate-400 mb-4 font-mono text-sm">Paste card list or upload a .txt file. Format: QTY CARDNAME. Scoped to current search set.</p>
            <div class="flex items-center gap-3 mb-3">
                <label class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-4 rounded-lg text-xs tracking-wider border border-white/10 cursor-pointer">
                    UPLOAD .TXT
                    <input type="file" id="importFileInput" accept=".txt" class="hidden">
                </label>
                <span id="importFileName" class="text-xs font-mono text-slate-500"></span>
            </div>
            <textarea id="importTextArea" class="w-full h-56 rounded-xl p-4 font-mono text-sm" placeholder="4x Sol Ring&#10;1x Black Lotus"></textarea>
            <div id="import-status" class="mt-4 text-sm h-6 text-purple-400 font-mono"></div>
            <div id="import-errors" class="mt-2 text-xs text-red-400 max-h-24 overflow-y-auto font-mono"></div>
            <div class="mt-6 flex justify-end gap-4">
                <button id="cancelImportBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 py-2 px-6 rounded-xl text-sm border border-white/10">CANCEL</button>
                <button id="processImportBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-6 rounded-xl text-sm">IMPORT</button>
            </div>
        </div>
    </div>

    <div id="visualViewModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div id="visualViewContent" class="rounded-2xl p-4 sm:p-6 w-full max-w-7xl h-[95vh] sm:h-[90vh] flex flex-col border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center mb-4 sm:mb-6">
                <h2 class="text-lg sm:text-2xl font-bold text-slate-100">Visual Grid</h2>
                <div class="flex items-center gap-4">
                    <button id="fullscreenBtn" title="Fullscreen" class="text-slate-400 hover:text-purple-400 transition-colors hidden sm:block">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                    </button>
                    <button id="exitFullscreenBtn" title="Exit Fullscreen" class="text-slate-400 hover:text-purple-400 hidden transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
                    </button>
                    <button id="closeVisualViewBtn" class="text-slate-500 hover:text-red-400 text-4xl leading-none">&times;</button>
                </div>
            </div>
            <div id="visual-view-body" class="flex-grow overflow-y-auto pr-2">
                <div id="visual-view-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                    </div>
            </div>
        </div>
    </div>

    <div id="photoStudioModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-1 sm:p-4">
        <div class="rounded-2xl p-0 w-full max-w-[95vw] h-[98vh] sm:h-[95vh] flex flex-col border border-white/10 shadow-2xl overflow-hidden" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center p-3 sm:p-4 border-b border-white/10 gap-3" style="background: rgba(20, 20, 35, 0.8);">
                <div class="flex items-center min-w-0">
                    <h2 class="text-base sm:text-2xl font-bold text-slate-100 tracking-wider truncate">Manifest</h2>
                    <span class="ml-3 text-xs font-mono text-slate-500 hidden md:inline">Image Generator</span>
                </div>

                <div class="flex gap-3 flex-shrink-0">
                    <button id="downloadPhotoBtn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 sm:px-6 rounded-xl text-xs sm:text-sm tracking-wide shadow-sm transition-colors whitespace-nowrap">DOWNLOAD</button>
                    <button id="closePhotoStudioBtn" class="text-slate-500 hover:text-red-400 text-3xl leading-none">&times;</button>
                </div>
            </div>

            <div id="photo-viewport">
                <div id="photo-stage">
                    </div>
            </div>
        </div>
    </div>

    <div id="ebayViewModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-4 sm:p-6 w-full max-w-6xl h-[95vh] sm:h-[90vh] flex flex-col border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 flex-shrink-0 border-b border-white/10 pb-4 gap-3">
                <div class="flex items-center justify-between w-full sm:w-auto">
                    <h2 class="text-lg sm:text-2xl font-bold text-slate-100 tracking-wider">List Generator</h2>
                    <button id="closeEbayViewBtn" class="text-slate-500 hover:text-red-400 text-3xl ml-2 sm:hidden">&times;</button>
                </div>
                <div class="flex gap-3 items-center w-full sm:w-auto">
                    <div class="flex items-center px-3 py-2 bg-white/5 rounded-lg border border-white/10">
                        <input type="checkbox" id="ebaySelectAll" class="h-4 w-4 rounded mr-2">
                        <label for="ebaySelectAll" class="text-sm font-mono text-slate-400 whitespace-nowrap">Select All</label>
                    </div>
                    <button id="copyEbayBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 sm:px-6 rounded-xl text-sm tracking-wide flex-grow sm:flex-grow-0">COPY</button>
                    <button class="ebay-close-desktop text-slate-500 hover:text-red-400 text-3xl ml-2 hidden sm:block">&times;</button>
                </div>
            </div>

            <div id="ebay-view-body" class="flex-grow overflow-y-auto bg-white/5 p-3 sm:p-6 border border-white/10 rounded-xl">
                <div id="ebayListContainer" class="checklist-container">
                    </div>
            </div>

            <div class="mt-3 text-slate-500 text-xs text-right flex-shrink-0 font-mono">
                Format: [QTY]x MTG [SET] [NAME] #[ID]
            </div>
        </div>
    </div>


    <!-- Card Detail Popover -->
    <div id="cardDetailModal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center p-2 sm:p-4" style="z-index:60;">
        <div class="rounded-2xl p-5 sm:p-8 w-full max-w-3xl max-h-[95vh] overflow-y-auto border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-start mb-4">
                <h2 id="detailCardName" class="text-2xl font-bold text-slate-100"></h2>
                <button id="closeCardDetailBtn" class="text-slate-500 hover:text-red-400 text-3xl leading-none ml-4">&times;</button>
            </div>
            <div id="cardDetailBody" class="flex flex-col md:flex-row gap-6">
                <div id="detailImageContainer" class="flex-shrink-0 w-full md:w-64">
                    <div class="card-flip-container">
                        <div id="detailFlipInner" class="card-flip-inner">
                            <div class="card-flip-front"><img id="detailCardImage" class="w-full rounded-lg" src=""></div>
                            <div class="card-flip-back"><img id="detailCardImageBack" class="w-full rounded-lg" src=""></div>
                        </div>
                    </div>
                    <button id="detailFlipBtn" class="hidden mt-2 w-full btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-1 px-3 rounded-lg text-xs border border-white/10">FLIP CARD ↻</button>
                </div>
                <div class="flex-grow space-y-4">
                    <div id="detailManaCost" class="flex items-center gap-1 flex-wrap"></div>
                    <p id="detailTypeLine" class="text-sm text-slate-400 font-mono border-b border-white/10 pb-2"></p>
                    <div id="detailOracleText" class="text-sm text-slate-300 whitespace-pre-wrap leading-relaxed"></div>
                    <div id="detailLegalities" class="flex flex-wrap gap-1 pt-2 border-t border-white/10"></div>
                    <div id="detailRulings" class="pt-2 border-t border-white/10 space-y-2 hidden">
                        <p class="text-xs font-mono text-slate-500 tracking-wider">RULINGS</p>
                        <div id="detailRulingsList" class="space-y-2 text-xs text-slate-400"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-5 sm:p-8 w-full max-w-3xl max-h-[95vh] overflow-y-auto border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-slate-100">Collection Stats</h2>
                <button id="closeStatsBtn" class="text-slate-500 hover:text-red-400 text-3xl leading-none">&times;</button>
            </div>
            <div id="statsBody"></div>
            <div class="mt-6 flex justify-center">
                <canvas id="colorWheelChart" width="280" height="280"></canvas>
            </div>
        </div>
    </div>

    <!-- Dupes Modal -->
    <div id="dupesModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-5 sm:p-8 w-full max-w-2xl max-h-[95vh] overflow-y-auto border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-slate-100">Duplicate Finder</h2>
                <button id="closeDupesBtn" class="text-slate-500 hover:text-red-400 text-3xl leading-none">&times;</button>
            </div>
            <div id="dupesBody"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // UI Elements
            const searchBtn = document.getElementById('searchBtn');
            const clearSearchBtn = document.getElementById('clearSearchBtn');
            const setCodeInput = document.getElementById('setCode');
            const searchResultsContainer = document.getElementById('searchResults');
            const inventoryContainer = document.getElementById('inventory');
            const totalValueEl = document.getElementById('totalValue');
            const totalCardsEl = document.getElementById('totalCards');
            const loader = document.getElementById('loader');
            const messageArea = document.getElementById('message-area');
            const currencySelect = document.getElementById('currency');
            const collectionSelector = document.getElementById('collectionSelector');
            const newCollectionNameInput = document.getElementById('newCollectionName');
            const createCollectionBtn = document.getElementById('createCollectionBtn');
            const renameCollectionBtn = document.getElementById('renameCollectionBtn');
            const updatePricesBtn = document.getElementById('updatePricesBtn');
            const importTxtBtn = document.getElementById('importTxtBtn');
            const exportTxtBtn = document.getElementById('exportTxtBtn');
            const visualViewBtn = document.getElementById('visualViewBtn');
            const photoStudioBtn = document.getElementById('photoStudioBtn');
            const ebayViewBtn = document.getElementById('ebayViewBtn');
            const saveCollectionsBtn = document.getElementById('saveCollectionsBtn');
            const deleteCollectionBtn = document.getElementById('deleteCollectionBtn');
            const includeDigitalCheckbox = document.getElementById('includeDigital');
            const uniquenessFilter = document.getElementById('uniquenessFilter');
            const sortOrderSelect = document.getElementById('sortOrder');
            const filterInput = document.getElementById('filterInput');

            // Pagination UI
            const paginationControls = document.getElementById('paginationControls');
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');

            // Modal UI Elements
            const importModal = document.getElementById('importModal');
            const importTextArea = document.getElementById('importTextArea');
            const importFileInput = document.getElementById('importFileInput');
            const importFileName = document.getElementById('importFileName');
            const importStatus = document.getElementById('import-status');
            const importErrors = document.getElementById('import-errors');
            const cancelImportBtn = document.getElementById('cancelImportBtn');
            const processImportBtn = document.getElementById('processImportBtn');

            // Visual View Modal
            const visualViewModal = document.getElementById('visualViewModal');
            const visualViewContent = document.getElementById('visualViewContent');
            const closeVisualViewBtn = document.getElementById('closeVisualViewBtn');
            const visualViewGrid = document.getElementById('visual-view-grid');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');

            // Manifest / Photo Studio Modal
            const photoStudioModal = document.getElementById('photoStudioModal');
            const closePhotoStudioBtn = document.getElementById('closePhotoStudioBtn');
            const photoStage = document.getElementById('photo-stage');
            const downloadPhotoBtn = document.getElementById('downloadPhotoBtn');

            // eBay View Modal
            const ebayViewModal = document.getElementById('ebayViewModal');
            const closeEbayViewBtn = document.getElementById('closeEbayViewBtn');
            const ebayListContainer = document.getElementById('ebayListContainer');
            const ebaySelectAll = document.getElementById('ebaySelectAll');
            const copyEbayBtn = document.getElementById('copyEbayBtn');

            // New Feature UI Elements
            const cardNameSearch = document.getElementById('cardNameSearch');
            const autocompleteDropdown = document.getElementById('autocompleteDropdown');
            const toggleFiltersBtn = document.getElementById('toggleFiltersBtn');
            const advancedFilters = document.getElementById('advancedFilters');
            const filterRarity = document.getElementById('filterRarity');
            const filterType = document.getElementById('filterType');
            const filterCmcMin = document.getElementById('filterCmcMin');
            const filterCmcMax = document.getElementById('filterCmcMax');
            const colorBtns = document.querySelectorAll('.color-btn');
            const statsBtn = document.getElementById('statsBtn');
            const dupesBtn = document.getElementById('dupesBtn');
            const legalityBtn = document.getElementById('legalityBtn');
            const exportDropdown = document.getElementById('exportDropdown');
            const collectionTypeSelector = document.getElementById('collectionTypeSelector');
            const priceChartContainer = document.getElementById('priceChartContainer');
            const priceHistoryCanvas = document.getElementById('priceHistoryChart');
            const cardDetailModal = document.getElementById('cardDetailModal');
            const closeCardDetailBtn = document.getElementById('closeCardDetailBtn');
            const detailFlipBtn = document.getElementById('detailFlipBtn');
            const detailFlipInner = document.getElementById('detailFlipInner');
            const statsModal = document.getElementById('statsModal');
            const closeStatsBtn = document.getElementById('closeStatsBtn');
            const statsBody = document.getElementById('statsBody');
            const dupesModal = document.getElementById('dupesModal');
            const closeDupesBtn = document.getElementById('closeDupesBtn');
            const dupesBody = document.getElementById('dupesBody');

            // App State
            let collections = {};
            let activeCollectionName = '';
            let currentCurrency = 'usd';
            let currentSearchResults = [];
            let currentPage = 1;
            const cardsPerPage = 20;

            // Undo/Redo
            let undoStack = [];
            let redoStack = [];
            const MAX_UNDO = 50;

            // Wishlist meta
            let collectionMeta = {};

            // Feature toggles
            let showLegality = false;
            let activeColorFilters = new Set();
            let priceChartInstance = null;
            let acDebounceTimer = null;

            // Mana Theme System
            const manaThemes = {
                default: { accent: '#8b5cf6', accentRgb: '139,92,246', accentLight: '#c4b5fd', accentLightRgb: '196,181,253', panelRgb: '120,100,180', bg: '#0a0a0f', bgLight: '#F0EDF5' },
                white:   { accent: '#C2A878', accentRgb: '194,168,120', accentLight: '#DDD0B5', accentLightRgb: '221,208,181', panelRgb: '170,150,120', bg: '#100e08', bgLight: '#F5F0E8' },
                blue:    { accent: '#1A7BBD', accentRgb: '26,123,189', accentLight: '#7CB5D9', accentLightRgb: '124,181,217', panelRgb: '60,110,170', bg: '#080a10', bgLight: '#EBF0F5' },
                black:   { accent: '#7C6B8A', accentRgb: '124,107,138', accentLight: '#B0A0C0', accentLightRgb: '176,160,192', panelRgb: '100,90,120', bg: '#09080c', bgLight: '#EDECE8' },
                red:     { accent: '#C92A2A', accentRgb: '201,42,42', accentLight: '#E88A8A', accentLightRgb: '232,138,138', panelRgb: '170,80,80', bg: '#100808', bgLight: '#F5EDEB' },
                green:   { accent: '#2D8B57', accentRgb: '45,139,87', accentLight: '#7DC4A0', accentLightRgb: '125,196,160', panelRgb: '60,130,90', bg: '#081008', bgLight: '#ECF5EE' }
            };
            let currentThemeName = 'default';

            function applyTheme(name) {
                const t = manaThemes[name];
                if (!t) return;
                currentThemeName = name;
                const s = document.body.style;
                const isLight = document.body.classList.contains('light-mode');
                s.setProperty('--accent', t.accent);
                s.setProperty('--accent-light', t.accentLight);
                s.setProperty('--accent-rgb', t.accentRgb);
                s.setProperty('--accent-light-rgb', t.accentLightRgb);
                s.setProperty('--panel-rgb', isLight ? t.panelRgb : t.panelRgb);
                s.setProperty('--bg', isLight ? t.bgLight : t.bg);
                document.querySelectorAll('.mana-orb').forEach(o => o.classList.remove('active'));
                document.querySelector(`.mana-orb[data-theme="${name}"]`)?.classList.add('active');
                localStorage.setItem('mtgTheme', name);
            }

            function toggleLightMode() {
                const body = document.body;
                const toggle = document.getElementById('lightModeToggle');
                body.classList.toggle('light-mode');
                const isLight = body.classList.contains('light-mode');
                toggle.textContent = isLight ? '☾' : '☀';
                localStorage.setItem('mtgLightMode', isLight ? '1' : '0');
                // Re-apply theme to swap bg
                const t = manaThemes[currentThemeName];
                if (t) body.style.setProperty('--bg', isLight ? t.bgLight : t.bg);
            }

            // Apply saved theme + light mode
            const savedTheme = localStorage.getItem('mtgTheme');
            if (savedTheme && manaThemes[savedTheme]) applyTheme(savedTheme);
            if (localStorage.getItem('mtgLightMode') === '1') toggleLightMode();

            // Load collections from local storage on page load
            loadCollections();
            checkShareLink();

            // Event Listeners
            searchBtn.addEventListener('click', searchBySetCode);
            clearSearchBtn.addEventListener('click', clearSearchResults);
            setCodeInput.addEventListener('keypress', (e) => e.key === 'Enter' && searchBySetCode());
            saveCollectionsBtn.addEventListener('click', saveCollections);
            deleteCollectionBtn.addEventListener('click', deleteCollection);
            createCollectionBtn.addEventListener('click', createCollection);
            newCollectionNameInput.addEventListener('keypress', (e) => e.key === 'Enter' && createCollection());
            renameCollectionBtn.addEventListener('click', renameCollection);
            updatePricesBtn.addEventListener('click', updateCollectionPrices);
            importTxtBtn.addEventListener('click', openImportModal);
            visualViewBtn.addEventListener('click', openVisualViewModal);
            photoStudioBtn.addEventListener('click', openManifestGenerator);
            ebayViewBtn.addEventListener('click', openEbayViewModal);
            collectionSelector.addEventListener('change', switchCollection);
            uniquenessFilter.addEventListener('change', () => {
                if (setCodeInput.value.trim()) {
                    searchBySetCode();
                }
            });
            currencySelect.addEventListener('change', (e) => {
                currentCurrency = e.target.value;
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
            });
            sortOrderSelect.addEventListener('change', () => {
                currentPage = 1;
                filterAndSortAndDisplayResults();
            });
            filterInput.addEventListener('input', () => {
                currentPage = 1;
                filterAndSortAndDisplayResults();
                filterInventory();
            });
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    filterAndSortAndDisplayResults();
                }
            });
            nextPageBtn.addEventListener('click', () => {
                currentPage++;
                filterAndSortAndDisplayResults();
            });

            cancelImportBtn.addEventListener('click', () => importModal.classList.add('hidden'));
            processImportBtn.addEventListener('click', processImport);
            importFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                importFileName.textContent = file.name;
                const reader = new FileReader();
                reader.onload = (ev) => { importTextArea.value = ev.target.result; };
                reader.readAsText(file);
            });

            // Visual View Listeners
            closeVisualViewBtn.addEventListener('click', () => visualViewModal.classList.add('hidden'));
            fullscreenBtn.addEventListener('click', () => visualViewContent.requestFullscreen());
            exitFullscreenBtn.addEventListener('click', () => document.exitFullscreen());
            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    fullscreenBtn.classList.add('hidden');
                    exitFullscreenBtn.classList.remove('hidden');
                } else {
                    fullscreenBtn.classList.remove('hidden');
                    exitFullscreenBtn.classList.add('hidden');
                }
            });

            // Photo Studio Listeners
            closePhotoStudioBtn.addEventListener('click', () => photoStudioModal.classList.add('hidden'));
            downloadPhotoBtn.addEventListener('click', generateAndDownloadPhoto);

            // eBay View Listeners
            closeEbayViewBtn.addEventListener('click', () => ebayViewModal.classList.add('hidden'));
            document.querySelector('.ebay-close-desktop')?.addEventListener('click', () => ebayViewModal.classList.add('hidden'));
            ebaySelectAll.addEventListener('change', (e) => {
                const checkboxes = ebayListContainer.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            });
            copyEbayBtn.addEventListener('click', copyEbayListToClipboard);

            // Mana Theme Orbs + Light Mode Toggle
            document.querySelectorAll('.mana-orb').forEach(orb => {
                orb.addEventListener('click', () => applyTheme(orb.dataset.theme));
            });
            document.getElementById('lightModeToggle').addEventListener('click', toggleLightMode);

            // New Feature Listeners
            statsBtn.addEventListener('click', openStatsModal);
            dupesBtn.addEventListener('click', openDupesModal);
            legalityBtn.addEventListener('click', () => {
                showLegality = !showLegality;
                legalityBtn.classList.toggle('bg-purple-600/30', showLegality);
                legalityBtn.classList.toggle('border-purple-500/40', showLegality);
                updateInventoryDisplay();
            });
            closeCardDetailBtn.addEventListener('click', () => cardDetailModal.classList.add('hidden'));
            closeStatsBtn.addEventListener('click', () => statsModal.classList.add('hidden'));
            closeDupesBtn.addEventListener('click', () => dupesModal.classList.add('hidden'));
            detailFlipBtn.addEventListener('click', () => detailFlipInner.classList.toggle('flipped'));

            // Export dropdown
            exportTxtBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                exportDropdown.classList.toggle('hidden');
            });
            document.addEventListener('click', () => exportDropdown.classList.add('hidden'));
            exportDropdown.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    exportDropdown.classList.add('hidden');
                    handleExport(btn.dataset.format);
                });
            });

            // Advanced filters
            toggleFiltersBtn.addEventListener('click', () => {
                advancedFilters.classList.toggle('hidden');
                toggleFiltersBtn.textContent = advancedFilters.classList.contains('hidden') ? 'FILTERS' : 'HIDE FILTERS';
            });
            filterRarity.addEventListener('change', () => { currentPage = 1; filterAndSortAndDisplayResults(); });
            filterType.addEventListener('change', () => { currentPage = 1; filterAndSortAndDisplayResults(); });
            filterCmcMin.addEventListener('input', () => { currentPage = 1; filterAndSortAndDisplayResults(); });
            filterCmcMax.addEventListener('input', () => { currentPage = 1; filterAndSortAndDisplayResults(); });
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const color = btn.dataset.color;
                    if (activeColorFilters.has(color)) {
                        activeColorFilters.delete(color);
                        btn.classList.remove('active');
                    } else {
                        activeColorFilters.add(color);
                        btn.classList.add('active');
                    }
                    currentPage = 1;
                    filterAndSortAndDisplayResults();
                });
            });

            // Autocomplete
            cardNameSearch.addEventListener('input', () => {
                clearTimeout(acDebounceTimer);
                const q = cardNameSearch.value.trim();
                if (q.length < 2) { autocompleteDropdown.classList.add('hidden'); return; }
                acDebounceTimer = setTimeout(() => fetchAutocomplete(q), 250);
            });
            cardNameSearch.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') autocompleteDropdown.classList.add('hidden');
            });
            document.addEventListener('click', (e) => {
                if (!cardNameSearch.contains(e.target) && !autocompleteDropdown.contains(e.target)) {
                    autocompleteDropdown.classList.add('hidden');
                }
            });

            // Keyboard Shortcuts
            document.addEventListener('keydown', (e) => {
                const isInput = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
                if ((e.ctrlKey || e.metaKey) && ((e.key === 'z' && e.shiftKey) || e.key === 'y')) { e.preventDefault(); redo(); }
                if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); saveCollections(); }
                if (e.key === 'Escape') closeTopmostModal();
                if (!isInput && e.key === 'ArrowLeft') { if (currentPage > 1) { currentPage--; filterAndSortAndDisplayResults(); } }
                if (!isInput && e.key === 'ArrowRight') {
                    const total = getFilteredCount();
                    const totalPages = Math.ceil(total / cardsPerPage);
                    if (currentPage < totalPages) { currentPage++; filterAndSortAndDisplayResults(); }
                }
            });


            /**
             * Fetches cards from the Scryfall API based on one or more set codes.
             */
            async function searchBySetCode() {
                const setCodesInput = setCodeInput.value.trim().toLowerCase();
                const setCodes = setCodesInput.split(',')
                    .map(code => code.trim())
                    .filter(code => code.length >= 3);

                if (setCodes.length === 0) {
                    showMessage('Enter a set code to search');
                    return;
                }

                showLoader(true);
                showMessage('Searching Scryfall...');
                searchResultsContainer.innerHTML = '';
                currentSearchResults = [];
                filterInput.value = '';
                paginationControls.classList.add('hidden');
                currentPage = 1;

                try {
                    const includeDigital = includeDigitalCheckbox.checked;
                    const setQuery = setCodes.map(code => `set%3A${code}`).join('+OR+');
                    let searchParams = `(${setQuery})`;

                    if (!includeDigital) {
                        searchParams += '+not%3Adigital';
                    }

                    const uniqueness = uniquenessFilter.value;
                    let allCards = [];
                    let nextPageUrl = `https://api.scryfall.com/cards/search?unique=${uniqueness}&q=${searchParams}`;

                    while (nextPageUrl) {
                        const response = await fetch(nextPageUrl);
                        if (!response.ok) {
                             if (response.status === 404) throw new Error(`Set not found`);
                            throw new Error(`HTTP error: ${response.status}`);
                        }
                        const data = await response.json();
                        allCards = allCards.concat(data.data);
                        nextPageUrl = data.has_more ? data.next_page : null;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    currentSearchResults = allCards;
                    filterAndSortAndDisplayResults();
                } catch (error) {
                    console.error('Error fetching data from Scryfall:', error);
                    showMessage(`Search failed: ${error.message}`);
                } finally {
                    showLoader(false);
                    if(currentSearchResults.length > 0) showMessage('');
                }
            }

            function clearSearchResults() {
                searchResultsContainer.innerHTML = '';
                currentSearchResults = [];
                setCodeInput.value = '';
                filterInput.value = '';
                showMessage('');
                paginationControls.classList.add('hidden');
                filterInventory();
            }

            function filterAndSortAndDisplayResults() {
                const filterText = filterInput.value.toLowerCase();
                let filteredResults = currentSearchResults;

                if (filterText) {
                    filteredResults = filteredResults.filter(card =>
                        card.name.toLowerCase().includes(filterText)
                    );
                }

                // Advanced filters
                const rarity = filterRarity.value;
                if (rarity) filteredResults = filteredResults.filter(c => c.rarity === rarity);

                const type = filterType.value;
                if (type) filteredResults = filteredResults.filter(c => c.type_line && c.type_line.toLowerCase().includes(type));

                const cmcMin = parseFloat(filterCmcMin.value);
                if (!isNaN(cmcMin)) filteredResults = filteredResults.filter(c => (c.cmc || 0) >= cmcMin);

                const cmcMax = parseFloat(filterCmcMax.value);
                if (!isNaN(cmcMax)) filteredResults = filteredResults.filter(c => (c.cmc || 0) <= cmcMax);

                if (activeColorFilters.size > 0) {
                    filteredResults = filteredResults.filter(c => {
                        const ci = c.color_identity || [];
                        return [...activeColorFilters].every(color => ci.includes(color));
                    });
                }

                const sortOrder = sortOrderSelect.value;
                filteredResults.sort((a, b) => {
                    switch (sortOrder) {
                        case 'name_asc':
                            return a.name.localeCompare(b.name);
                        case 'name_desc':
                            return b.name.localeCompare(a.name);
                        case 'price_desc':
                            const priceA_desc = parseFloat(a.prices[currentCurrency]) || 0;
                            const priceB_desc = parseFloat(b.prices[currentCurrency]) || 0;
                            return priceB_desc - priceA_desc;
                        case 'price_asc':
                            const priceA_asc = parseFloat(a.prices[currentCurrency]) || Infinity;
                            const priceB_asc = parseFloat(b.prices[currentCurrency]) || Infinity;
                            return priceA_asc - priceB_asc;
                        default:
                            return 0;
                    }
                });

                displaySearchResults(filteredResults);
                updatePaginationControls(filteredResults.length);
            }

            function displaySearchResults(cards) {
                searchResultsContainer.innerHTML = '';

                const startIndex = (currentPage - 1) * cardsPerPage;
                const endIndex = startIndex + cardsPerPage;
                const paginatedCards = cards.slice(startIndex, endIndex);

                if (paginatedCards.length === 0 && (setCodeInput.value.trim() !== '' || filterInput.value.trim() !== '')) {
                    showMessage('No results match filter');
                    return;
                }

                paginatedCards.forEach(card => {
                    const price = card.prices[currentCurrency] || 'N/A';
                    const foilPrice = card.prices[`${currentCurrency}_foil`] || 'N/A';

                    const inventory = collections[activeCollectionName] || [];
                    const inventoryCardNormal = inventory.find(item => item.id === card.id && !item.isFoil);
                    const inventoryCardFoil = inventory.find(item => item.id === card.id && item.isFoil);
                    const quantityNormal = inventoryCardNormal ? inventoryCardNormal.quantity : 0;
                    const quantityFoil = inventoryCardFoil ? inventoryCardFoil.quantity : 0;

                    const cardElement = document.createElement('div');
                    cardElement.className = 'card rounded-lg overflow-hidden flex flex-col';
                    cardElement.setAttribute('data-card-id', card.id);
                    const isDfc = card.card_faces && card.card_faces.length >= 2 && card.card_faces[0].image_uris && card.card_faces[1].image_uris;
                    const flipHtml = isDfc ? `<div class="flip-icon" data-flip>↻</div>` : '';
                    const frontImg = getCardImage(card, 'normal');
                    const backImg = isDfc ? card.card_faces[1].image_uris.normal : '';
                    cardElement.innerHTML = `
                        <div class="relative card-flip-container">
                            <div class="card-flip-inner" data-flip-inner>
                                <div class="card-flip-front">
                                    <img src="${frontImg}" alt="${card.name}" class="w-full h-auto cursor-pointer" data-detail onerror="this.onerror=null;this.src='https://placehold.co/223x310/1a1a2e/8b5cf6?text=No+Image';">
                                </div>
                                ${isDfc ? `<div class="card-flip-back"><img src="${backImg}" alt="${card.name} (back)" class="w-full h-auto"></div>` : ''}
                            </div>
                            ${flipHtml}
                        </div>
                        <div class="p-3 sm:p-4 flex-grow flex flex-col justify-between">
                            <h3 class="font-bold text-sm sm:text-base truncate text-slate-100 font-mono tracking-tighter">${card.name}</h3>
                            <div class="mt-3 space-y-2">
                                <div class="flex items-center justify-between">
                                    <p class="text-xs text-slate-400 font-mono">Reg: <span class="text-green-400">${getCurrencySymbol()}${price}</span></p>
                                    <div class="flex items-center gap-1">
                                        <button class="remove-one-btn quantity-btn flex items-center justify-center bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 rounded text-red-400 font-bold transition-all text-xs" data-foil="false">-</button>
                                        <span class="quantity-display-normal font-bold text-sm w-6 text-center font-mono text-slate-200">${quantityNormal}</span>
                                        <button class="add-one-btn quantity-btn flex items-center justify-center bg-green-500/10 hover:bg-green-500/20 border border-green-500/20 rounded text-green-400 font-bold transition-all text-xs" data-foil="false">+</button>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between border-t border-white/5 pt-2">
                                    <p class="text-xs text-slate-400 font-mono">Foil: <span class="text-amber-400">${getCurrencySymbol()}${foilPrice}</span></p>
                                    <div class="flex items-center gap-1">
                                        <button class="remove-one-btn quantity-btn flex items-center justify-center bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 rounded text-red-400 font-bold transition-all text-xs" data-foil="true">-</button>
                                        <span class="quantity-display-foil font-bold text-sm w-6 text-center font-mono text-amber-400">${quantityFoil}</span>
                                        <button class="add-one-btn quantity-btn flex items-center justify-center bg-green-500/10 hover:bg-green-500/20 border border-green-500/20 rounded text-green-400 font-bold transition-all text-xs" data-foil="true">+</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    cardElement.querySelectorAll('.add-one-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (!activeCollectionName) { showMessage("No active collection"); return; }
                            const isFoil = btn.dataset.foil === 'true';
                            addToInventory(card, 1, isFoil);
                        });
                    });

                    cardElement.querySelectorAll('.remove-one-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (!activeCollectionName) { showMessage("No active collection"); return; }
                            const isFoil = btn.dataset.foil === 'true';
                            removeFromInventory(card.id, isFoil);
                        });
                    });

                    // Detail popover on image click
                    const detailImg = cardElement.querySelector('[data-detail]');
                    if (detailImg) detailImg.addEventListener('click', () => openCardDetail(card));

                    // DFC flip
                    const flipIcon = cardElement.querySelector('[data-flip]');
                    if (flipIcon) {
                        flipIcon.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cardElement.querySelector('[data-flip-inner]').classList.toggle('flipped');
                        });
                    }

                    searchResultsContainer.appendChild(cardElement);
                });
            }

            function updatePaginationControls(totalCards) {
                if (totalCards <= cardsPerPage) {
                    paginationControls.classList.add('hidden');
                    return;
                }

                paginationControls.classList.remove('hidden');
                const totalPages = Math.ceil(totalCards / cardsPerPage);
                pageInfo.textContent = `Page ${currentPage} / ${totalPages}`;

                prevPageBtn.disabled = currentPage === 1;
                nextPageBtn.disabled = currentPage === totalPages;
            }

            function updateCardQuantityInSearchResults(cardId) {
                const cardElements = searchResultsContainer.querySelectorAll(`[data-card-id="${cardId}"]`);
                cardElements.forEach(cardElement => {
                    const inventory = collections[activeCollectionName] || [];
                    const inventoryCardNormal = inventory.find(item => item.id === cardId && !item.isFoil);
                    const inventoryCardFoil = inventory.find(item => item.id === cardId && item.isFoil);

                    cardElement.querySelector('.quantity-display-normal').textContent = inventoryCardNormal ? inventoryCardNormal.quantity : 0;
                    cardElement.querySelector('.quantity-display-foil').textContent = inventoryCardFoil ? inventoryCardFoil.quantity : 0;
                });
            }

            function addToInventory(card, quantityToAdd, isFoil, skipUndo = false) {
                if (!skipUndo) pushUndoState('Add ' + card.name);
                const currentInventory = collections[activeCollectionName];
                const inventoryId = card.id + (isFoil ? '_foil' : '_normal');
                const existingCard = currentInventory.find(item => item.inventoryId === inventoryId);

                if (existingCard) {
                    existingCard.quantity += quantityToAdd;
                } else {
                    currentInventory.push({ ...card, quantity: quantityToAdd, isFoil: isFoil, inventoryId: inventoryId });
                }

                updateInventoryDisplay();
                updateCardQuantityInSearchResults(card.id);
            }

            function removeFromInventory(cardId, isFoil) {
                pushUndoState('Remove card');
                const currentInventory = collections[activeCollectionName];
                const inventoryId = cardId + (isFoil ? '_foil' : '_normal');
                const cardIndex = currentInventory.findIndex(item => item.inventoryId === inventoryId);

                if (cardIndex > -1) {
                    currentInventory[cardIndex].quantity--;
                    if (currentInventory[cardIndex].quantity === 0) {
                        currentInventory.splice(cardIndex, 1);
                    }
                    updateInventoryDisplay();
                    updateCardQuantityInSearchResults(cardId);
                }
            }

            function updateInventoryDisplay() {
                inventoryContainer.innerHTML = '';
                let totalValue = 0;
                let totalCards = 0;
                const currentInventory = collections[activeCollectionName];

                if (!currentInventory || currentInventory.length === 0) {
                    inventoryContainer.innerHTML = '<p class="text-slate-500 font-mono text-sm text-center py-4">No cards in collection</p>';
                    totalValueEl.textContent = `${getCurrencySymbol()}0.00`;
                    totalCardsEl.textContent = '0';
                    return;
                }

                currentInventory.sort((a,b) => a.name.localeCompare(b.name) || (a.isFoil - b.isFoil));

                const isWishlist = (collectionMeta[activeCollectionName] || {}).type === 'wishlist';

                currentInventory.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    totalValue += price * card.quantity;
                    totalCards += card.quantity;
                    const inventoryItem = document.createElement('div');
                    inventoryItem.className = `inventory-item flex items-center justify-between bg-white/5 p-2 rounded-lg border border-white/10 hover:border-purple-500/30 transition-colors group ${isWishlist ? 'wishlist-item' : ''}`;
                    inventoryItem.dataset.cardName = card.name.toLowerCase();

                    const foilBadge = card.isFoil ? '<span class="text-amber-400 font-bold ml-1 text-xs tracking-wider">[FOIL]</span>' : '';
                    const wantedLabel = isWishlist ? '<span class="text-purple-400 text-[9px] font-mono ml-1">WANTED</span>' : '';

                    // Format legality badges
                    let legalityHtml = '';
                    if (showLegality && card.legalities) {
                        const fmtMap = {standard:'STD',modern:'MOD',commander:'CMD',pioneer:'PIO',legacy:'LEG',vintage:'VIN',pauper:'PAU'};
                        Object.entries(fmtMap).forEach(([k,v]) => {
                            if (card.legalities[k] === 'legal') legalityHtml += `<span class="fmt-badge">${v}</span>`;
                        });
                    }

                    inventoryItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden flex-1 min-w-0">
                            <div class="w-8 h-8 rounded bg-cover bg-center flex-shrink-0 border border-white/10 cursor-pointer" style="background-image: url('${getCardImage(card, 'small')}');" data-inv-detail></div>
                            <div class="min-w-0 flex-1">
                                <p class="font-semibold text-slate-300 truncate text-sm font-mono group-hover:text-slate-100 transition-colors">${card.name} ${foilBadge}${wantedLabel}</p>
                                <div class="flex items-center gap-1 text-xs text-slate-500 font-mono">
                                    <span>${getCurrencySymbol()}${price.toFixed(2)} x</span>
                                    <input type="number" class="inline-qty" value="${card.quantity}" min="0" data-inv-id="${card.inventoryId}">
                                </div>
                                ${legalityHtml ? `<div class="mt-1">${legalityHtml}</div>` : ''}
                            </div>
                        </div>
                        <div class="flex gap-1 flex-shrink-0">
                            <button class="move-btn bg-white/5 hover:bg-purple-500/20 text-purple-400 font-bold py-1 px-2 rounded-lg text-[9px] transition-colors border border-purple-500/20" data-inv-id="${card.inventoryId}">MOV</button>
                            <button class="remove-from-inventory-btn bg-white/5 hover:bg-red-500/20 text-red-400 hover:text-red-300 font-bold py-1 px-2 rounded-lg text-[9px] transition-colors border border-red-500/20" data-card-id="${card.id}" data-foil="${card.isFoil}">DEL</button>
                        </div>
                    `;

                    // Detail popover from thumbnail
                    inventoryItem.querySelector('[data-inv-detail]').addEventListener('click', () => openCardDetail(card));

                    // Inline quantity edit
                    inventoryItem.querySelector('.inline-qty').addEventListener('change', (e) => {
                        const newQty = parseInt(e.target.value) || 0;
                        pushUndoState('Edit qty ' + card.name);
                        if (newQty <= 0) {
                            const idx = currentInventory.findIndex(c => c.inventoryId === card.inventoryId);
                            if (idx > -1) currentInventory.splice(idx, 1);
                        } else {
                            card.quantity = newQty;
                        }
                        updateInventoryDisplay();
                        updateCardQuantityInSearchResults(card.id);
                    });

                    // Move button
                    inventoryItem.querySelector('.move-btn').addEventListener('click', () => moveCard(card));

                    inventoryItem.querySelector('.remove-from-inventory-btn').addEventListener('click', (e) => {
                        const isFoil = e.target.dataset.foil === 'true';
                        removeFromInventory(e.target.dataset.cardId, isFoil);
                    });
                    inventoryContainer.appendChild(inventoryItem);
                });

                totalValueEl.textContent = `${getCurrencySymbol()}${totalValue.toFixed(2)}`;
                totalCardsEl.textContent = totalCards;
                filterInventory();
            }

            function filterInventory() {
                const filterText = filterInput.value.toLowerCase();
                const inventoryItems = inventoryContainer.querySelectorAll('.inventory-item');
                inventoryItems.forEach(item => {
                    const cardName = item.dataset.cardName;
                    if (cardName.includes(filterText)) {
                        item.classList.remove('hidden');
                    } else {
                        item.classList.add('hidden');
                    }
                });
            }

            function saveCollections() {
                localStorage.setItem('mtgCollections', JSON.stringify(collections));
                localStorage.setItem('mtgCollectionMeta', JSON.stringify(collectionMeta));
                recordPriceSnapshot();
                updatePriceChart();
                showMessage('Saved to local storage');
            }

            async function loadCollections() {
                const savedCollections = localStorage.getItem('mtgCollections');
                if (savedCollections) {
                    collections = JSON.parse(savedCollections);
                } else {
                    collections = { 'Main Collection': [] };
                }

                // Load wishlist meta
                const savedMeta = localStorage.getItem('mtgCollectionMeta');
                if (savedMeta) collectionMeta = JSON.parse(savedMeta);

                const needsSave = await migrateCollections(collections);
                if (needsSave) {
                    saveCollections();
                }

                if (Object.keys(collections).length > 0) {
                    activeCollectionName = Object.keys(collections)[0];
                } else {
                    collections = { 'Main Collection': [] };
                    activeCollectionName = 'Main Collection';
                }

                updateCollectionSelector();
                updateInventoryDisplay();
                updatePriceChart();
            }

            async function updateCollectionPrices() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }
                pushUndoState('Sync prices');
                const collection = collections[activeCollectionName];
                const ids = [...new Set(collection.map(c => c.id))].map(id => ({ id }));

                showLoader(true);
                showMessage("Syncing prices...");

                try {
                    const fullCardDataMap = new Map();
                    const CHUNK_SIZE = 75;

                    for (let i = 0; i < ids.length; i += CHUNK_SIZE) {
                        const chunk = ids.slice(i, i + CHUNK_SIZE);
                        const response = await fetch('https://api.scryfall.com/cards/collection', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ identifiers: chunk })
                        });

                        if (!response.ok) throw new Error("API connection failed");
                        const result = await response.json();
                        result.data.forEach(card => fullCardDataMap.set(card.id, card));

                        await new Promise(r => setTimeout(r, 100));
                    }

                    collections[activeCollectionName] = collection.map(oldCard => {
                        if (fullCardDataMap.has(oldCard.id)) {
                            const newCardData = fullCardDataMap.get(oldCard.id);
                            return {
                                ...newCardData,
                                quantity: oldCard.quantity,
                                isFoil: oldCard.isFoil,
                                inventoryId: oldCard.inventoryId
                            };
                        }
                        return oldCard;
                    });

                    saveCollections();
                    updateInventoryDisplay();
                    showMessage("Prices updated");
                } catch (e) {
                    console.error(e);
                    showMessage("Update failed — check connection");
                } finally {
                    showLoader(false);
                }
            }

            async function migrateCollections(collectionsToMigrate) {
                let identifiersToFetch = [];
                for (const collectionName in collectionsToMigrate) {
                    collectionsToMigrate[collectionName].forEach(card => {
                        if (!card.image_uris && card.id) {
                            identifiersToFetch.push({ id: card.id });
                        }
                    });
                }

                if (identifiersToFetch.length === 0) {
                    return false;
                }

                const uniqueIdentifiers = [...new Map(identifiersToFetch.map(item => [item.id, item])).values()];
                const fullCardDataMap = new Map();
                const CHUNK_SIZE = 75;

                showMessage("Migrating data...");
                try {
                    for (let i = 0; i < uniqueIdentifiers.length; i += CHUNK_SIZE) {
                        const chunk = uniqueIdentifiers.slice(i, i + CHUNK_SIZE);
                        const response = await fetch('https://api.scryfall.com/cards/collection', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ identifiers: chunk })
                        });

                        if (!response.ok) {
                            throw new Error(`API error: ${response.status}`);
                        }
                        const result = await response.json();
                        if (result.data) {
                            result.data.forEach(card => fullCardDataMap.set(card.id, card));
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    for (const collectionName in collectionsToMigrate) {
                        collectionsToMigrate[collectionName] = collectionsToMigrate[collectionName].map(card => {
                            if (!card.image_uris && fullCardDataMap.has(card.id)) {
                                const fullCardData = fullCardDataMap.get(card.id);
                                const { quantity, isFoil, inventoryId } = card;
                                return { ...fullCardData, quantity, isFoil, inventoryId };
                            }
                            return card;
                        });
                    }
                    showMessage("Migration complete");
                    return true;
                } catch (error) {
                    console.error("Failed to migrate collection data:", error);
                    showMessage("Migration error — check console");
                    return false;
                }
            }

            function createCollection() {
                const newName = newCollectionNameInput.value.trim();
                if (newName && !collections[newName]) {
                    pushUndoState('Create ' + newName);
                    collections[newName] = [];
                    collectionMeta[newName] = { type: collectionTypeSelector.value };
                    activeCollectionName = newName;
                    newCollectionNameInput.value = '';
                    collectionTypeSelector.value = 'collection';
                    updateCollectionSelector();
                    updateInventoryDisplay();
                    showMessage(`Collection "${newName}" created`);
                } else if (collections[newName]) {
                    showMessage('Collection already exists');
                } else {
                    showMessage('Enter a collection name');
                }
            }

            function renameCollection() {
                if (!activeCollectionName) {
                    showMessage("Select a collection first");
                    return;
                }
                const newName = prompt(`Rename "${activeCollectionName}" to:`, activeCollectionName);
                if (newName && newName.trim() !== '' && newName !== activeCollectionName) {
                    if (collections[newName]) {
                        showMessage(`"${newName}" already exists`);
                        return;
                    }
                    pushUndoState('Rename ' + activeCollectionName);
                    // Transfer meta
                    if (collectionMeta[activeCollectionName]) {
                        collectionMeta[newName] = collectionMeta[activeCollectionName];
                        delete collectionMeta[activeCollectionName];
                    }
                    Object.defineProperty(collections, newName,
                        Object.getOwnPropertyDescriptor(collections, activeCollectionName));
                    delete collections[activeCollectionName];

                    activeCollectionName = newName;
                    updateCollectionSelector();
                    showMessage(`Renamed to "${newName}"`);
                    saveCollections();
                }
            }

            function handleExport(format) {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Nothing to export");
                    return;
                }
                const collection = collections[activeCollectionName];
                const safeFileName = activeCollectionName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

                if (format === 'share') {
                    generateShareLink();
                    return;
                }

                let content = '';
                let mimeType = 'text/plain';
                let ext = 'txt';

                if (format === 'txt') {
                    let totalCards = 0, totalValue = 0;
                    collection.forEach(card => {
                        totalCards += card.quantity;
                        const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                        totalValue += price * card.quantity;
                    });
                    content = `${activeCollectionName}\nTotal Cards: ${totalCards}\nTotal Value: ${getCurrencySymbol()}${totalValue.toFixed(2)}\n\n`;
                    collection.forEach(card => {
                        const setCode = card.set ? card.set.toUpperCase() : '';
                        const collectorNumber = card.collector_number || '';
                        const rarity = card.rarity ? card.rarity.charAt(0).toUpperCase() + card.rarity.slice(1) : '';
                        const foilText = card.isFoil ? ' (Foil)' : '';
                        const price = parseFloat(card.isFoil ? card.prices[currentCurrency + '_foil'] : card.prices[currentCurrency]) || 0;
                        let details = [];
                        if (setCode) details.push(setCode);
                        if (collectorNumber) details.push(`#${collectorNumber}`);
                        if (rarity) details.push(rarity);
                        let detailsString = details.length > 0 ? ` (${details.join(' - ')})` : '';
                        content += `${card.quantity}x ${card.name}${foilText}${detailsString} - ${getCurrencySymbol()}${price.toFixed(2)}\n`;
                    });
                } else if (format === 'moxfield') {
                    collection.forEach(card => {
                        const setCode = (card.set || '').toUpperCase();
                        const num = card.collector_number || '';
                        const foil = card.isFoil ? ' *F*' : '';
                        content += `${card.quantity} ${card.name} (${setCode}) ${num}${foil}\n`;
                    });
                } else if (format === 'archidekt') {
                    collection.forEach(card => {
                        const setCode = (card.set || '').toUpperCase();
                        const foil = card.isFoil ? ' *foil*' : '';
                        content += `${card.quantity}x ${card.name} [${setCode}]${foil}\n`;
                    });
                } else if (format === 'csv') {
                    ext = 'csv';
                    mimeType = 'text/csv';
                    content = 'Name,Set,Rarity,Quantity,Foil,Price,Value,Colors,Type,CMC\n';
                    collection.forEach(card => {
                        const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                        const colors = (card.color_identity || []).join('');
                        const name = `"${card.name.replace(/"/g, '""')}"`;
                        content += `${name},${(card.set||'').toUpperCase()},${card.rarity||''},${card.quantity},${card.isFoil},${price.toFixed(2)},${(price*card.quantity).toFixed(2)},${colors},"${(card.type_line||'').replace(/"/g,'""')}",${card.cmc||0}\n`;
                    });
                }

                const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `${safeFileName}_${format}.${ext}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                showMessage(`Exported as ${format.toUpperCase()}`);
            }

            function deleteCollection() {
                const collectionNames = Object.keys(collections);
                if (collectionNames.length === 0 || !activeCollectionName) {
                    showMessage("No collection to delete");
                    return;
                }
                if (confirm(`Delete "${activeCollectionName}"? This cannot be undone.`)) {
                    pushUndoState('Delete ' + activeCollectionName);
                    delete collectionMeta[activeCollectionName];
                    delete collections[activeCollectionName];
                    const remainingNames = Object.keys(collections);
                    if (remainingNames.length > 0) {
                        activeCollectionName = remainingNames[0];
                    } else {
                        collections = { 'Main Collection': [] };
                        activeCollectionName = 'Main Collection';
                    }
                    updateCollectionSelector();
                    updateInventoryDisplay();
                    showMessage(`Collection deleted`);
                    saveCollections();
                }
            }

            function switchCollection(e) {
                activeCollectionName = e.target.value;
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
                updatePriceChart();
            }

            function updateCollectionSelector() {
                collectionSelector.innerHTML = '';
                Object.keys(collections).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    const meta = collectionMeta[name] || {};
                    const prefix = meta.type === 'wishlist' ? '[W] ' : '';
                    option.textContent = prefix + name;
                    if (name === activeCollectionName) {
                        option.selected = true;
                    }
                    collectionSelector.appendChild(option);
                });
            }

            function getCardImage(card, size = 'normal') {
                const placeholderUrl = size === 'small'
                    ? 'https://placehold.co/146x204/1a1a2e/8b5cf6?text=No+Image'
                    : 'https://placehold.co/223x310/1a1a2e/8b5cf6?text=No+Image';

                if (card.image_uris && card.image_uris[size]) {
                    return card.image_uris[size];
                }

                if (card.card_faces && card.card_faces.length > 0 && card.card_faces[0].image_uris && card.card_faces[0].image_uris[size]) {
                    return card.card_faces[0].image_uris[size];
                }

                return placeholderUrl;
            }

            function getCurrencySymbol() {
                switch (currentCurrency) {
                    case 'eur': return '\u20AC';
                    case 'tix': return 'TIX ';
                    default: return '$';
                }
            }

            function showLoader(isLoading) {
                loader.classList.toggle('hidden', !isLoading);
                loader.classList.toggle('flex', isLoading);
            }

            function showMessage(text) {
                messageArea.textContent = text;
                if (text) {
                    setTimeout(() => messageArea.textContent = '', 3000);
                }
            }

            function openVisualViewModal() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }
                const collection = collections[activeCollectionName];
                const uniqueCardsMap = new Map();
                collection.forEach(card => {
                    if (uniqueCardsMap.has(card.id)) {
                        const existing = uniqueCardsMap.get(card.id);
                        existing.totalQuantity += card.quantity;
                        uniqueCardsMap.set(card.id, existing);
                    } else {
                        uniqueCardsMap.set(card.id, { cardData: card, totalQuantity: card.quantity });
                    }
                });
                const uniqueCards = Array.from(uniqueCardsMap.values()).sort((a, b) => a.cardData.name.localeCompare(b.cardData.name));
                visualViewGrid.innerHTML = '';
                if (uniqueCards.length === 0) {
                    visualViewGrid.innerHTML = '<p class="col-span-full text-center text-slate-500">No cards to display</p>';
                } else {
                    uniqueCards.forEach(item => {
                        const card = item.cardData;
                        const totalQuantity = item.totalQuantity;
                        const isDfc = card.card_faces && card.card_faces.length >= 2 && card.card_faces[0].image_uris && card.card_faces[1].image_uris;
                        const container = document.createElement('div');
                        container.className = 'relative group';

                        if (isDfc) {
                            container.innerHTML = `
                                <div class="card-flip-container">
                                    <div class="card-flip-inner" data-flip-inner>
                                        <div class="card-flip-front">
                                            <img src="${card.card_faces[0].image_uris.normal}" class="w-full h-auto rounded-lg border border-transparent group-hover:border-purple-500/40 transition-all cursor-pointer" data-vdetail>
                                        </div>
                                        <div class="card-flip-back">
                                            <img src="${card.card_faces[1].image_uris.normal}" class="w-full h-auto rounded-lg">
                                        </div>
                                    </div>
                                    <div class="flip-icon" data-flip>↻</div>
                                </div>`;
                            container.querySelector('[data-flip]').addEventListener('click', (e) => {
                                e.stopPropagation();
                                container.querySelector('[data-flip-inner]').classList.toggle('flipped');
                            });
                        } else {
                            const img = document.createElement('img');
                            img.src = getCardImage(card, 'normal');
                            img.className = 'w-full h-auto rounded-lg border border-transparent group-hover:border-purple-500/40 transition-all cursor-pointer';
                            img.setAttribute('data-vdetail', '');
                            container.appendChild(img);
                        }

                        const quantityBadge = document.createElement('div');
                        quantityBadge.className = 'absolute top-0 right-0 bg-black/70 text-slate-200 text-sm font-bold px-2 py-1 rounded-bl-lg border-l border-b border-white/10 backdrop-blur-sm z-10';
                        quantityBadge.textContent = `${totalQuantity}`;
                        container.appendChild(quantityBadge);

                        // Detail click
                        const detailTarget = container.querySelector('[data-vdetail]');
                        if (detailTarget) detailTarget.addEventListener('click', () => openCardDetail(card));

                        visualViewGrid.appendChild(container);
                    });
                }
                visualViewModal.classList.remove('hidden');
            }

            // --- MANIFEST GENERATOR LOGIC (REVISED 2.0) ---
            function openManifestGenerator() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }

                const collection = collections[activeCollectionName];

                // Consolidate duplicates
                const uniqueMap = new Map();
                collection.forEach(card => {
                    const key = card.id + (card.isFoil ? '_foil' : '_norm');
                    if (uniqueMap.has(key)) {
                        uniqueMap.get(key).quantity += card.quantity;
                    } else {
                        uniqueMap.set(key, { ...card });
                    }
                });
                const sortedCollection = Array.from(uniqueMap.values());

                // Sort by Value High->Low for Highlights
                const valueSorted = [...sortedCollection].sort((a, b) => {
                    const priceA = parseFloat(a.isFoil ? a.prices[`${currentCurrency}_foil`] : a.prices[currentCurrency]) || 0;
                    const priceB = parseFloat(b.isFoil ? b.prices[`${currentCurrency}_foil`] : b.prices[currentCurrency]) || 0;
                    return priceB - priceA;
                });

                // --- BUILD HTML ---
                const totalVal = totalValueEl.textContent;
                const totalCnt = totalCardsEl.textContent;
                const dateStr = new Date().toLocaleDateString();

                // 1. Header
                let html = `
                    <div class="manifest-header">
                        <div>
                            <h2 class="text-3xl font-bold text-gray-900 tracking-tight mb-1">${activeCollectionName.toUpperCase()}</h2>
                            <p class="text-sm text-gray-500 font-mono">INVENTORY MANIFEST // ${dateStr}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-xs text-gray-500 font-mono mb-1 uppercase tracking-widest">Est. Market Value</p>
                            <p class="text-4xl font-bold text-slate-800 tracking-tighter">${totalVal}</p>
                            <p class="text-xs text-gray-400 mt-1">${totalCnt} ITEMS</p>
                        </div>
                    </div>
                `;

                // 2. High Value Grid (Top 4)
                html += `<div class="manifest-highlights"><p class="text-xs font-bold text-gray-400 mb-4 uppercase tracking-widest">Premium Assets</p><div class="highlight-grid">`;

                const topItems = valueSorted.slice(0, 4);
                topItems.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    html += `
                        <div class="highlight-card">
                            <div class="highlight-img-container">
                                <img src="${getCardImage(card, 'normal')}?cb=1" crossOrigin="anonymous" onerror="this.onerror=null;this.style.display='none';">
                            </div>
                            <div class="w-full">
                                <p class="text-xs font-bold text-gray-800 truncate w-full">${card.name}</p>
                                <p class="text-xs text-green-600 font-mono mt-1">${getCurrencySymbol()}${price.toFixed(2)}</p>
                            </div>
                        </div>
                    `;
                });

                for(let i=topItems.length; i<4; i++) {
                     html += `<div class="highlight-card opacity-0"></div>`;
                }

                html += `</div></div>`;

                // 3. The Full List
                html += `<div class="manifest-list-container">`;

                // Sort Alphabetically
                const alphaCollection = [...sortedCollection].sort((a,b) => a.name.localeCompare(b.name));

                alphaCollection.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    const foilLabel = card.isFoil ? '<span class="text-amber-600 text-[10px] font-bold border border-amber-200 px-1 rounded ml-1">FOIL</span>' : '';
                    const setDisplay = card.set ? card.set.toUpperCase() : '---';
                    const collectorNumber = card.collector_number ? `#${card.collector_number}` : '';

                    html += `
                        <div class="manifest-row">
                            <div class="flex items-baseline overflow-hidden w-full">
                                <span class="font-mono font-bold text-gray-400 w-6 flex-shrink-0 text-right mr-2">${card.quantity}x</span>
                                <span class="font-semibold text-slate-700 truncate flex-grow">${card.name}</span>
                                ${foilLabel}
                            </div>
                            <div class="flex items-baseline flex-shrink-0 ml-2">
                                <span class="text-[11px] text-gray-400 font-mono mr-3 whitespace-nowrap">${setDisplay} ${collectorNumber}</span>
                                <span class="font-mono text-slate-600 text-xs w-14 text-right">${getCurrencySymbol()}${price.toFixed(2)}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;

                // 4. Footer
                html += `
                    <div class="bg-gray-100 p-4 border-t border-gray-200 text-center">
                         <p class="text-xs text-gray-400 font-mono">GENERATED BY MTG CARD VAULT</p>
                    </div>
                `;

                photoStage.innerHTML = html;
                photoStudioModal.classList.remove('hidden');
            }

            async function generateAndDownloadPhoto() {
                const btnOriginalText = downloadPhotoBtn.textContent;
                downloadPhotoBtn.textContent = "RENDERING...";
                downloadPhotoBtn.disabled = true;

                try {
                    await new Promise(r => setTimeout(r, 200));

                    const canvas = await html2canvas(photoStage, {
                        backgroundColor: '#ffffff',
                        useCORS: true,
                        scale: 2
                    });

                    const link = document.createElement('a');
                    link.download = `${activeCollectionName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_manifest.png`;
                    link.href = canvas.toDataURL("image/png");
                    link.click();

                    showMessage("Manifest downloaded");
                } catch (err) {
                    console.error("Photo generation failed:", err);
                    showMessage("Render error — check console");
                    alert("Image generation failed. Check console for details.");
                } finally {
                    downloadPhotoBtn.textContent = btnOriginalText;
                    downloadPhotoBtn.disabled = false;
                }
            }


            // --- eBay View Functions ---
            function openEbayViewModal() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }

                const collection = collections[activeCollectionName];
                ebayListContainer.innerHTML = '';
                ebaySelectAll.checked = false;

                // Sort for easier reading: Name, then Foil
                collection.sort((a,b) => a.name.localeCompare(b.name) || (a.isFoil - b.isFoil));

                collection.forEach(card => {
                    const foilText = card.isFoil ? '(Foil)' : '';

                    // Generate eBay Description String
                    let ebayString = `${card.quantity}x MTG ${card.set_name} ${card.name}`;
                    if (card.isFoil) ebayString += ' Foil';
                    ebayString += ` #${card.collector_number}`;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'checklist-item text-sm group';
                    itemDiv.innerHTML = `
                        <input type="checkbox" class="rounded mr-3" data-ebay-title="${ebayString}">
                        <span class="font-bold mr-2 text-slate-400 w-8 text-right font-mono">${card.quantity}x</span>
                        <span class="truncate text-slate-300 group-hover:text-slate-100 transition-colors">${card.name} <span class="text-amber-400 text-xs font-mono">${foilText}</span></span>
                    `;
                    ebayListContainer.appendChild(itemDiv);
                });

                ebayViewModal.classList.remove('hidden');
            }

            function copyEbayListToClipboard() {
                const checkboxes = ebayListContainer.querySelectorAll('input[type="checkbox"]:checked');
                if (checkboxes.length === 0) {
                    alert("Select at least one item.");
                    return;
                }

                let textToCopy = "";
                checkboxes.forEach(cb => {
                    textToCopy += cb.dataset.ebayTitle + "\n";
                });

                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalText = copyEbayBtn.textContent;
                    copyEbayBtn.textContent = "COPIED";
                    copyEbayBtn.classList.remove('bg-purple-600', 'hover:bg-purple-500');
                    copyEbayBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    setTimeout(() => {
                        copyEbayBtn.textContent = originalText;
                        copyEbayBtn.classList.add('bg-purple-600', 'hover:bg-purple-500');
                        copyEbayBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                });
            }


            // --- Import Modal Logic ---
            function openImportModal() {
                if (!activeCollectionName) {
                    showMessage("Select a collection first");
                    return;
                }
                importTextArea.value = '';
                importFileInput.value = '';
                importFileName.textContent = '';
                importStatus.textContent = '';
                importErrors.textContent = '';
                importModal.classList.remove('hidden');
            }

            async function processImport() {
                const text = importTextArea.value;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) {
                    importStatus.textContent = "No input data";
                    return;
                }
                pushUndoState('Import cards');
                processImportBtn.disabled = true;
                cancelImportBtn.disabled = true;
                importErrors.innerHTML = '';
                importStatus.textContent = "Parsing cards...";
                let errors = [];
                let successes = 0;

                // Parse all lines
                const parsed = [];
                for (const line of lines) {
                    if (!line.match(/^\d+\s*x?/)) continue;

                    let processedLine = line;
                    const isFoil = processedLine.toLowerCase().includes('(foil)');
                    if (isFoil) processedLine = processedLine.replace(/\(Foil\)/ig, '').trim();

                    const priceMatch = processedLine.match(/\s*-\s*\$[0-9.]+/);
                    if (priceMatch) processedLine = processedLine.substring(0, priceMatch.index).trim();

                    let setCode = null;
                    let collectorNumber = null;
                    const detailMatch = processedLine.match(/\(([^)]+)\)/);
                    if (detailMatch) {
                        const details = detailMatch[1];
                        const setMatch = details.match(/^([A-Za-z0-9]+)/);
                        if (setMatch) setCode = setMatch[1].toLowerCase();
                        const numMatch = details.match(/#([a-zA-Z0-9]+)/);
                        if (numMatch) collectorNumber = numMatch[1];
                        processedLine = processedLine.substring(0, detailMatch.index).trim();
                    }

                    const quantityMatch = processedLine.match(/^(\d+)\s*x?\s*/);
                    if (!quantityMatch) { errors.push(`Parse error: "${line}"`); continue; }

                    const quantity = parseInt(quantityMatch[1], 10);
                    const cardName = processedLine.substring(quantityMatch[0].length).trim();
                    if (!cardName) { errors.push(`Missing card name: "${line}"`); continue; }

                    parsed.push({ cardName, quantity, isFoil, setCode, collectorNumber, originalLine: line });
                }

                // Split into API-fetchable (has set+collector) and fallback (match against search results)
                const apiFetchable = parsed.filter(p => p.setCode && p.collectorNumber);
                const fallback = parsed.filter(p => !p.setCode || !p.collectorNumber);

                // Fetch cards from Scryfall Collection API in chunks of 75
                if (apiFetchable.length > 0) {
                    const chunks = [];
                    for (let i = 0; i < apiFetchable.length; i += 75) {
                        chunks.push(apiFetchable.slice(i, i + 75));
                    }

                    for (let ci = 0; ci < chunks.length; ci++) {
                        const chunk = chunks[ci];
                        importStatus.textContent = `Fetching cards from Scryfall... (batch ${ci + 1}/${chunks.length})`;

                        const identifiers = chunk.map(p => ({
                            set: p.setCode,
                            collector_number: p.collectorNumber
                        }));

                        try {
                            const resp = await fetch('https://api.scryfall.com/cards/collection', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ identifiers })
                            });

                            if (!resp.ok) throw new Error(`Scryfall API error: ${resp.status}`);
                            const data = await resp.json();

                            const fetchedCards = data.data || [];
                            const notFound = data.not_found || [];

                            // Match fetched cards back to parsed entries
                            for (const p of chunk) {
                                const card = fetchedCards.find(c =>
                                    c.set.toLowerCase() === p.setCode &&
                                    c.collector_number.toLowerCase() === p.collectorNumber.toLowerCase()
                                );
                                if (card) {
                                    addToInventory(card, p.quantity, p.isFoil, true);
                                    successes++;
                                } else {
                                    errors.push(`Not found: "${p.cardName}" (${p.setCode.toUpperCase()} #${p.collectorNumber})`);
                                }
                            }

                            // Respect Scryfall rate limit (100ms between requests)
                            if (ci < chunks.length - 1) await new Promise(r => setTimeout(r, 150));
                        } catch (err) {
                            for (const p of chunk) {
                                errors.push(`API error: "${p.cardName}" — ${err.message}`);
                            }
                        }
                    }
                }

                // Fallback: match against current search results
                for (const p of fallback) {
                    let foundCard;
                    if (p.collectorNumber) {
                        foundCard = currentSearchResults.find(card =>
                            card.name.toLowerCase() === p.cardName.toLowerCase() &&
                            card.collector_number.toLowerCase() === p.collectorNumber.toLowerCase()
                        );
                    } else {
                        foundCard = currentSearchResults.find(card =>
                            card.name.toLowerCase() === p.cardName.toLowerCase()
                        );
                    }

                    if (foundCard) {
                        addToInventory(foundCard, p.quantity, p.isFoil, true);
                        successes++;
                    } else {
                        errors.push(`Not found: "${p.cardName}" (no set info — search a set first)`);
                    }
                }

                importStatus.textContent = `Import complete. ${successes} cards added.`;
                if (errors.length > 0) {
                    importErrors.innerHTML = `<strong>Errors (${errors.length}):</strong><br>` + errors.join('<br>');
                }

                updateInventoryDisplay();
                filterAndSortAndDisplayResults();

                setTimeout(() => {
                    importModal.classList.add('hidden');
                    processImportBtn.disabled = false;
                    cancelImportBtn.disabled = false;
                }, 3500);
            }

            // ===== UNDO / REDO =====
            function pushUndoState(label) {
                undoStack.push({
                    label,
                    collections: JSON.parse(JSON.stringify(collections)),
                    activeCollectionName,
                    collectionMeta: JSON.parse(JSON.stringify(collectionMeta))
                });
                if (undoStack.length > MAX_UNDO) undoStack.shift();
                redoStack = [];
            }

            function undo() {
                if (undoStack.length === 0) { showMessage('Nothing to undo'); return; }
                redoStack.push({
                    label: 'redo',
                    collections: JSON.parse(JSON.stringify(collections)),
                    activeCollectionName,
                    collectionMeta: JSON.parse(JSON.stringify(collectionMeta))
                });
                const state = undoStack.pop();
                collections = state.collections;
                activeCollectionName = state.activeCollectionName;
                collectionMeta = state.collectionMeta;
                updateCollectionSelector();
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
                showMessage(`Undo: ${state.label}`);
            }

            function redo() {
                if (redoStack.length === 0) { showMessage('Nothing to redo'); return; }
                undoStack.push({
                    label: 'undo',
                    collections: JSON.parse(JSON.stringify(collections)),
                    activeCollectionName,
                    collectionMeta: JSON.parse(JSON.stringify(collectionMeta))
                });
                const state = redoStack.pop();
                collections = state.collections;
                activeCollectionName = state.activeCollectionName;
                collectionMeta = state.collectionMeta;
                updateCollectionSelector();
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
                showMessage('Redo');
            }

            // ===== KEYBOARD HELPERS =====
            function closeTopmostModal() {
                const modals = [cardDetailModal, statsModal, dupesModal, importModal, visualViewModal, photoStudioModal, ebayViewModal];
                for (const m of modals) {
                    if (!m.classList.contains('hidden')) { m.classList.add('hidden'); return; }
                }
                if (!exportDropdown.classList.contains('hidden')) exportDropdown.classList.add('hidden');
            }

            function getFilteredCount() {
                let f = currentSearchResults;
                const ft = filterInput.value.toLowerCase();
                if (ft) f = f.filter(c => c.name.toLowerCase().includes(ft));
                const r = filterRarity.value;
                if (r) f = f.filter(c => c.rarity === r);
                const t = filterType.value;
                if (t) f = f.filter(c => c.type_line && c.type_line.toLowerCase().includes(t));
                const cmin = parseFloat(filterCmcMin.value);
                if (!isNaN(cmin)) f = f.filter(c => (c.cmc||0) >= cmin);
                const cmax = parseFloat(filterCmcMax.value);
                if (!isNaN(cmax)) f = f.filter(c => (c.cmc||0) <= cmax);
                if (activeColorFilters.size > 0) f = f.filter(c => [...activeColorFilters].every(cl => (c.color_identity||[]).includes(cl)));
                return f.length;
            }

            // ===== AUTOCOMPLETE =====
            async function fetchAutocomplete(q) {
                try {
                    const resp = await fetch(`https://api.scryfall.com/cards/autocomplete?q=${encodeURIComponent(q)}`);
                    if (!resp.ok) return;
                    const data = await resp.json();
                    if (!data.data || data.data.length === 0) { autocompleteDropdown.classList.add('hidden'); return; }
                    autocompleteDropdown.innerHTML = '';
                    data.data.slice(0, 10).forEach(name => {
                        const item = document.createElement('div');
                        item.className = 'ac-item';
                        item.textContent = name;
                        item.addEventListener('click', () => {
                            cardNameSearch.value = name;
                            autocompleteDropdown.classList.add('hidden');
                            searchByCardName(name);
                        });
                        autocompleteDropdown.appendChild(item);
                    });
                    autocompleteDropdown.classList.remove('hidden');
                } catch (e) { console.error('Autocomplete error:', e); }
            }

            async function searchByCardName(name) {
                showLoader(true);
                showMessage('Searching all prints...');
                searchResultsContainer.innerHTML = '';
                currentSearchResults = [];
                currentPage = 1;
                try {
                    let allCards = [];
                    let url = `https://api.scryfall.com/cards/search?unique=prints&q=!"${encodeURIComponent(name)}"`;
                    while (url) {
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`Not found`);
                        const data = await resp.json();
                        allCards = allCards.concat(data.data);
                        url = data.has_more ? data.next_page : null;
                        await new Promise(r => setTimeout(r, 100));
                    }
                    currentSearchResults = allCards;
                    filterAndSortAndDisplayResults();
                    showMessage(`Found ${allCards.length} prints of "${name}"`);
                } catch (e) {
                    showMessage(`Search failed: ${e.message}`);
                } finally {
                    showLoader(false);
                }
            }

            // ===== CARD DETAIL POPOVER =====
            async function openCardDetail(card) {
                const nameEl = document.getElementById('detailCardName');
                const imgEl = document.getElementById('detailCardImage');
                const imgBackEl = document.getElementById('detailCardImageBack');
                const typeEl = document.getElementById('detailTypeLine');
                const oracleEl = document.getElementById('detailOracleText');
                const manaEl = document.getElementById('detailManaCost');
                const legalEl = document.getElementById('detailLegalities');
                const rulingsDiv = document.getElementById('detailRulings');
                const rulingsList = document.getElementById('detailRulingsList');

                detailFlipInner.classList.remove('flipped');
                const isDfc = card.card_faces && card.card_faces.length >= 2 && card.card_faces[0].image_uris && card.card_faces[1].image_uris;

                nameEl.textContent = card.name;
                imgEl.src = isDfc ? card.card_faces[0].image_uris.normal : getCardImage(card, 'normal');

                if (isDfc) {
                    imgBackEl.src = card.card_faces[1].image_uris.normal;
                    detailFlipBtn.classList.remove('hidden');
                } else {
                    detailFlipBtn.classList.add('hidden');
                }

                // Type line
                typeEl.textContent = isDfc ? card.card_faces[0].type_line : (card.type_line || '');

                // Mana cost
                const manaCost = isDfc ? (card.card_faces[0].mana_cost || '') : (card.mana_cost || '');
                manaEl.innerHTML = renderManaCost(manaCost);

                // Oracle text
                if (isDfc) {
                    oracleEl.textContent = (card.card_faces[0].oracle_text || '') + '\n---\n' + (card.card_faces[1].oracle_text || '');
                } else {
                    oracleEl.textContent = card.oracle_text || '';
                }

                // Legalities
                legalEl.innerHTML = '';
                if (card.legalities) {
                    const fmtMap = {standard:'STD',modern:'MOD',commander:'CMD',pioneer:'PIO',legacy:'LEG',vintage:'VIN',pauper:'PAU',historic:'HIS',brawl:'BRL'};
                    Object.entries(fmtMap).forEach(([k,v]) => {
                        const status = card.legalities[k];
                        let color = 'bg-red-500/20 text-red-400 border-red-500/30';
                        if (status === 'legal') color = 'bg-green-500/20 text-green-400 border-green-500/30';
                        else if (status === 'restricted') color = 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30';
                        else if (status === 'banned') color = 'bg-red-500/20 text-red-400 border-red-500/30';
                        else color = 'bg-white/5 text-slate-500 border-white/10';
                        legalEl.innerHTML += `<span class="inline-block px-2 py-0.5 rounded text-[10px] font-mono font-bold border ${color}">${v}</span>`;
                    });
                }

                // Rulings
                rulingsDiv.classList.add('hidden');
                rulingsList.innerHTML = '';
                cardDetailModal.classList.remove('hidden');

                if (card.rulings_uri) {
                    try {
                        const resp = await fetch(card.rulings_uri);
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.data && data.data.length > 0) {
                                rulingsDiv.classList.remove('hidden');
                                data.data.slice(0, 10).forEach(r => {
                                    rulingsList.innerHTML += `<div class="p-2 bg-white/5 rounded text-xs text-slate-400"><span class="text-slate-600 mr-2">${r.published_at}</span>${r.comment}</div>`;
                                });
                            }
                        }
                    } catch (e) { /* rulings fetch failed, non-critical */ }
                }
            }

            function renderManaCost(cost) {
                if (!cost) return '';
                const colors = { W:'#F9FAF4;color:#333', U:'#0E68AB;color:#fff', B:'#150B00;color:#fff', R:'#D3202A;color:#fff', G:'#00733E;color:#fff', C:'#CAC5C0;color:#333' };
                return cost.replace(/\{([^}]+)\}/g, (_, sym) => {
                    const bg = colors[sym] || '#CAC5C0;color:#333';
                    return `<span class="mana-symbol" style="background:${bg}">${sym}</span>`;
                });
            }

            // ===== STATS DASHBOARD =====
            function openStatsModal() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty"); return;
                }
                const coll = collections[activeCollectionName];
                let totalVal = 0, totalQty = 0, uniqueCards = new Set();
                const rarityCounts = {common:0,uncommon:0,rare:0,mythic:0};
                const colorCounts = {W:0,U:0,B:0,R:0,G:0,C:0};
                const setCounts = {};

                coll.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    totalVal += price * card.quantity;
                    totalQty += card.quantity;
                    uniqueCards.add(card.id);
                    if (card.rarity && rarityCounts[card.rarity] !== undefined) rarityCounts[card.rarity] += card.quantity;
                    const ci = card.color_identity || [];
                    if (ci.length === 0) colorCounts.C += card.quantity;
                    else ci.forEach(c => { if (colorCounts[c] !== undefined) colorCounts[c] += card.quantity; });
                    const setName = card.set_name || card.set || '???';
                    setCounts[setName] = (setCounts[setName] || 0) + card.quantity;
                });

                const avgVal = uniqueCards.size > 0 ? (totalVal / uniqueCards.size) : 0;

                let html = `<div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
                    <div class="bg-white/5 rounded-lg p-3 border border-white/10 text-center"><p class="text-[10px] text-slate-500 font-mono">TOTAL VALUE</p><p class="text-lg font-bold text-green-400">${getCurrencySymbol()}${totalVal.toFixed(2)}</p></div>
                    <div class="bg-white/5 rounded-lg p-3 border border-white/10 text-center"><p class="text-[10px] text-slate-500 font-mono">TOTAL CARDS</p><p class="text-lg font-bold text-slate-200">${totalQty}</p></div>
                    <div class="bg-white/5 rounded-lg p-3 border border-white/10 text-center"><p class="text-[10px] text-slate-500 font-mono">UNIQUE</p><p class="text-lg font-bold text-purple-400">${uniqueCards.size}</p></div>
                    <div class="bg-white/5 rounded-lg p-3 border border-white/10 text-center"><p class="text-[10px] text-slate-500 font-mono">AVG VALUE</p><p class="text-lg font-bold text-slate-300">${getCurrencySymbol()}${avgVal.toFixed(2)}</p></div>
                </div>`;

                // Rarity bars
                const maxRarity = Math.max(...Object.values(rarityCounts), 1);
                const rarityColors = {common:'#9ca3af',uncommon:'#60a5fa',rare:'#facc15',mythic:'#f97316'};
                html += `<h3 class="text-xs font-mono text-slate-500 mb-2 tracking-wider">RARITY BREAKDOWN</h3>`;
                Object.entries(rarityCounts).forEach(([r, cnt]) => {
                    const pct = (cnt / maxRarity * 100).toFixed(0);
                    html += `<div class="stat-bar-container"><div class="stat-bar-label"><span>${r.charAt(0).toUpperCase()+r.slice(1)}</span><span>${cnt}</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:${pct}%;background:${rarityColors[r]}"></div></div></div>`;
                });

                // Color bars
                const maxColor = Math.max(...Object.values(colorCounts), 1);
                const colorStyles = {W:'#F9FAF4',U:'#0E68AB',B:'#555',R:'#D3202A',G:'#00733E',C:'#CAC5C0'};
                html += `<h3 class="text-xs font-mono text-slate-500 mb-2 mt-4 tracking-wider">COLOR BREAKDOWN</h3>`;
                Object.entries(colorCounts).forEach(([c, cnt]) => {
                    const pct = (cnt / maxColor * 100).toFixed(0);
                    html += `<div class="stat-bar-container"><div class="stat-bar-label"><span>${c}</span><span>${cnt}</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:${pct}%;background:${colorStyles[c]}"></div></div></div>`;
                });

                // Top 10 sets
                const topSets = Object.entries(setCounts).sort((a,b) => b[1]-a[1]).slice(0, 10);
                const maxSet = topSets.length > 0 ? topSets[0][1] : 1;
                html += `<h3 class="text-xs font-mono text-slate-500 mb-2 mt-4 tracking-wider">TOP SETS</h3>`;
                topSets.forEach(([s, cnt]) => {
                    const pct = (cnt / maxSet * 100).toFixed(0);
                    html += `<div class="stat-bar-container"><div class="stat-bar-label"><span class="truncate max-w-[200px]">${s}</span><span>${cnt}</span></div><div class="stat-bar-track"><div class="stat-bar-fill" style="width:${pct}%;background:#8b5cf6"></div></div></div>`;
                });

                statsBody.innerHTML = html;

                // Color wheel (Chart.js doughnut)
                const cwCanvas = document.getElementById('colorWheelChart');
                const existingChart = Chart.getChart(cwCanvas);
                if (existingChart) existingChart.destroy();
                new Chart(cwCanvas, {
                    type: 'doughnut',
                    data: {
                        labels: ['White','Blue','Black','Red','Green','Colorless'],
                        datasets: [{
                            data: [colorCounts.W, colorCounts.U, colorCounts.B, colorCounts.R, colorCounts.G, colorCounts.C],
                            backgroundColor: ['#F9FAF4','#0E68AB','#555555','#D3202A','#00733E','#CAC5C0'],
                            borderColor: 'rgba(15,15,25,0.9)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: { position: 'bottom', labels: { color: '#94a3b8', font: { family: 'Share Tech Mono', size: 11 } } }
                        }
                    }
                });

                statsModal.classList.remove('hidden');
            }

            // ===== DUPLICATE FINDER =====
            function openDupesModal() {
                const allCollNames = Object.keys(collections);
                if (allCollNames.length < 2) { showMessage("Need 2+ collections to find dupes"); return; }

                const cardLocations = {};
                allCollNames.forEach(name => {
                    (collections[name] || []).forEach(card => {
                        const key = card.name;
                        if (!cardLocations[key]) cardLocations[key] = {};
                        if (!cardLocations[key][name]) cardLocations[key][name] = 0;
                        cardLocations[key][name] += card.quantity;
                    });
                });

                const dupes = Object.entries(cardLocations).filter(([_, locs]) => Object.keys(locs).length >= 2);
                dupes.sort((a, b) => a[0].localeCompare(b[0]));

                let html = '';
                if (dupes.length === 0) {
                    html = '<p class="text-slate-500 font-mono text-sm text-center py-8">No duplicates found across collections</p>';
                } else {
                    html = `<p class="text-xs text-slate-500 font-mono mb-4">${dupes.length} cards found in multiple collections</p>`;
                    dupes.forEach(([name, locs]) => {
                        html += `<div class="bg-white/5 rounded-lg p-3 border border-white/10 mb-2"><p class="font-semibold text-slate-200 text-sm font-mono">${name}</p><div class="mt-1">`;
                        Object.entries(locs).forEach(([coll, qty]) => {
                            html += `<span class="inline-block mr-2 text-xs font-mono text-purple-400 bg-purple-500/10 px-2 py-0.5 rounded border border-purple-500/20">${coll}: ${qty}x</span>`;
                        });
                        html += `</div></div>`;
                    });
                }
                dupesBody.innerHTML = html;
                dupesModal.classList.remove('hidden');
            }

            // ===== MOVE CARD =====
            function moveCard(card) {
                const otherCollections = Object.keys(collections).filter(n => n !== activeCollectionName);
                if (otherCollections.length === 0) { showMessage("No other collections"); return; }
                const target = prompt(`Move "${card.name}" to:\n\n${otherCollections.map((n,i) => `${i+1}. ${n}`).join('\n')}\n\nEnter collection name:`);
                if (!target || !collections[target]) { if (target) showMessage("Collection not found"); return; }
                pushUndoState('Move ' + card.name);
                // Remove from current
                const srcInv = collections[activeCollectionName];
                const srcIdx = srcInv.findIndex(c => c.inventoryId === card.inventoryId);
                if (srcIdx === -1) return;
                const movedCard = srcInv.splice(srcIdx, 1)[0];
                // Add to target
                const tgtInv = collections[target];
                const tgtId = movedCard.id + (movedCard.isFoil ? '_foil' : '_normal');
                const existing = tgtInv.find(c => c.inventoryId === tgtId);
                if (existing) {
                    existing.quantity += movedCard.quantity;
                } else {
                    tgtInv.push({ ...movedCard, inventoryId: tgtId });
                }
                updateInventoryDisplay();
                updateCardQuantityInSearchResults(card.id);
                showMessage(`Moved to "${target}"`);
            }

            // ===== SHARE LINK =====
            function generateShareLink() {
                const coll = collections[activeCollectionName];
                if (!coll || coll.length === 0) { showMessage("Nothing to share"); return; }
                const minimal = coll.map(c => ({ s: c.set, n: c.collector_number, q: c.quantity, f: c.isFoil ? 1 : 0 }));
                const json = JSON.stringify(minimal);
                const compressed = LZString.compressToEncodedURIComponent(json);
                const url = window.location.origin + window.location.pathname + '#share=' + compressed;
                navigator.clipboard.writeText(url).then(() => {
                    showMessage("Share link copied to clipboard");
                }).catch(() => {
                    prompt("Copy this share link:", url);
                });
            }

            async function checkShareLink() {
                const hash = window.location.hash;
                if (!hash.startsWith('#share=')) return;
                const compressed = hash.substring(7);
                try {
                    const json = LZString.decompressFromEncodedURIComponent(compressed);
                    const cards = JSON.parse(json);
                    if (!Array.isArray(cards) || cards.length === 0) return;

                    showLoader(true);
                    showMessage('Loading shared collection...');

                    const collName = `Shared ${new Date().toLocaleDateString()}`;
                    collections[collName] = [];
                    activeCollectionName = collName;

                    const identifiers = cards.map(c => ({ set: c.s, collector_number: String(c.n) }));
                    const CHUNK = 75;
                    const cardMap = new Map();

                    for (let i = 0; i < identifiers.length; i += CHUNK) {
                        const chunk = identifiers.slice(i, i + CHUNK);
                        const resp = await fetch('https://api.scryfall.com/cards/collection', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ identifiers: chunk })
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            (data.data || []).forEach(c => cardMap.set(c.set + '|' + c.collector_number, c));
                        }
                        await new Promise(r => setTimeout(r, 100));
                    }

                    cards.forEach(c => {
                        const key = c.s + '|' + String(c.n);
                        const fullCard = cardMap.get(key);
                        if (fullCard) {
                            const isFoil = !!c.f;
                            const invId = fullCard.id + (isFoil ? '_foil' : '_normal');
                            collections[collName].push({ ...fullCard, quantity: c.q, isFoil, inventoryId: invId });
                        }
                    });

                    updateCollectionSelector();
                    updateInventoryDisplay();
                    saveCollections();
                    history.replaceState(null, '', window.location.pathname);
                    showMessage(`Imported shared collection: ${collName}`);
                } catch (e) {
                    console.error('Share link error:', e);
                    showMessage('Invalid share link');
                } finally {
                    showLoader(false);
                }
            }

            // ===== PRICE HISTORY =====
            function recordPriceSnapshot() {
                const history = JSON.parse(localStorage.getItem('mtgPriceHistory') || '{}');
                const today = new Date().toISOString().split('T')[0];

                Object.keys(collections).forEach(name => {
                    if (!history[name]) history[name] = [];
                    let totalVal = 0;
                    (collections[name] || []).forEach(card => {
                        const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                        totalVal += price * card.quantity;
                    });

                    const existing = history[name].findIndex(e => e.date === today);
                    if (existing >= 0) {
                        history[name][existing].value = totalVal;
                    } else {
                        history[name].push({ date: today, value: totalVal });
                    }
                    if (history[name].length > 365) history[name] = history[name].slice(-365);
                });

                localStorage.setItem('mtgPriceHistory', JSON.stringify(history));
            }

            function updatePriceChart() {
                const history = JSON.parse(localStorage.getItem('mtgPriceHistory') || '{}');
                const data = history[activeCollectionName];

                if (!data || data.length < 2) {
                    priceChartContainer.classList.add('hidden');
                    return;
                }

                priceChartContainer.classList.remove('hidden');
                if (priceChartInstance) priceChartInstance.destroy();

                const labels = data.map(d => d.date.slice(5)); // MM-DD
                const values = data.map(d => d.value);

                priceChartInstance = new Chart(priceHistoryCanvas, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            data: values,
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { display: true, ticks: { maxTicksToShow: 5, color: '#475569', font: { size: 9 } }, grid: { display: false } },
                            y: { display: true, ticks: { color: '#475569', font: { size: 9 }, callback: v => getCurrencySymbol() + v.toFixed(0) }, grid: { color: 'rgba(255,255,255,0.03)' } }
                        }
                    }
                });
            }

        });
    </script>
</body>
</html>
