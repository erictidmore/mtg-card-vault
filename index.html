<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Card Vault</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0f;
            color: #e2e8f0;
        }

        h1, h2, h3, button {
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Glass Panels */
        .clean-panel {
            background: rgba(20, 20, 35, 0.7);
            border: 1px solid rgba(120, 100, 180, 0.15);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        /* Input Fields */
        input[type="text"], select, textarea, input[type="range"] {
            background: rgba(15, 15, 25, 0.8) !important;
            border: 1px solid rgba(120, 100, 180, 0.2) !important;
            color: #e2e8f0 !important;
            font-family: 'Share Tech Mono', monospace;
            transition: all 0.2s ease;
        }
        input[type="text"]:focus, select:focus, textarea:focus {
            border-color: #8b5cf6 !important;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.15);
            outline: none;
        }
        input[type="text"]::placeholder, textarea::placeholder {
            color: #64748b !important;
        }
        select option {
            background: #1a1a2e;
            color: #e2e8f0;
        }

        /* Cards */
        .card {
            background: rgba(20, 20, 35, 0.7);
            border: 1px solid rgba(120, 100, 180, 0.15);
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
        }

        /* Buttons */
        .btn-clean {
            transition: all 0.2s;
            font-weight: 600;
        }
        .btn-clean:hover {
            filter: brightness(1.1);
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 15, 0.5);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 92, 246, 0.5);
        }

        /* Loader */
        .loader {
            border-top-color: #8b5cf6;
            border-right-color: #c4b5fd;
            border-bottom-color: #8b5cf6;
            border-left-color: #c4b5fd;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Quantity Buttons - touch targets */
        .quantity-btn {
            min-width: 28px;
            min-height: 28px;
        }
        @media (max-width: 639px) {
            .quantity-btn {
                min-width: 36px;
                min-height: 36px;
            }
        }

        /* Checklist View */
        .checklist-container {
            column-width: 280px;
            column-gap: 2rem;
            width: 100%;
        }
        .checklist-item {
            break-inside: avoid;
            page-break-inside: avoid;
            display: flex;
            align-items: center;
            border-bottom: 1px dotted rgba(120, 100, 180, 0.2);
            padding: 6px 0;
            font-family: 'Share Tech Mono', monospace;
            color: #94a3b8;
            transition: color 0.2s;
        }
        .checklist-item:hover {
            background-color: rgba(139, 92, 246, 0.06);
            color: #e2e8f0;
        }

        .modal-overlay {
            background: rgba(5, 5, 10, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* Manifest Studio â€” stays LIGHT for PNG export */
        #photo-viewport {
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: #3a3a4a;
            height: 100%;
            width: 100%;
            padding: 40px;
        }

        #photo-stage {
            width: 1200px;
            max-width: 100%;
            background: #ffffff;
            color: #0f172a;
            position: relative;
            padding: 0;
            box-sizing: border-box;
            box-shadow: 0 4px 30px rgba(0,0,0,0.4);
            margin: 0 auto;
            min-height: 800px;
            font-family: 'Inter', sans-serif;
        }
        @media (max-width: 639px) {
            #photo-viewport {
                padding: 12px;
            }
        }

        .manifest-header {
            background: #f1f5f9;
            border-bottom: 4px solid #334155;
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .manifest-highlights {
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            width: 100%;
        }

        .highlight-card {
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .highlight-img-container {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            overflow: hidden;
            border-radius: 4px;
            margin-bottom: 8px;
            background: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .highlight-img-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .manifest-list-container {
            padding: 40px;
            column-count: 3;
            column-gap: 40px;
            column-rule: 1px solid #e2e8f0;
        }
        @media (max-width: 900px) {
            .manifest-list-container {
                column-count: 2;
                padding: 24px;
                column-gap: 24px;
            }
            .highlight-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            .manifest-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
                padding: 20px 24px;
            }
            .manifest-header > div:last-child {
                text-align: left;
            }
            .manifest-highlights {
                padding: 20px 24px;
            }
        }
        @media (max-width: 500px) {
            .manifest-list-container {
                column-count: 1;
                padding: 16px;
            }
            .highlight-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .manifest-row {
            break-inside: avoid;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            border-bottom: 1px dotted #cbd5e1;
            padding: 3px 0;
            font-size: 13px;
            line-height: 1.4;
        }

        .manifest-row:last-child {
            border-bottom: none;
        }

        /* Range Slider Styling */
        input[type=range] {
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(120, 100, 180, 0.3);
            border-radius: 2px;
        }

        /* Checkbox styling */
        input[type="checkbox"] {
            accent-color: #8b5cf6;
        }
    </style>
</head>
<body class="min-h-screen">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-6 sm:mb-10 relative">
            <h1 class="text-3xl sm:text-5xl md:text-6xl font-bold text-slate-100 tracking-tight">MTG Card Vault</h1>
            <p class="text-purple-400 mt-2 font-mono text-sm tracking-widest">COLLECTION MANAGER</p>
        </header>

        <div class="mb-6 sm:mb-8 p-4 sm:p-6 rounded-2xl clean-panel relative">
            <h2 class="text-2xl font-bold mb-4 text-slate-100 flex items-center">
                <span class="inline-block w-1 h-6 bg-purple-500 mr-3 rounded-sm"></span>
                Card Search
            </h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="setCode" class="flex-grow rounded-xl px-4 py-3" placeholder="Enter set codes (e.g. LTR, MOM)">
                <button id="searchBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-8 rounded-xl">SEARCH</button>
                <button id="clearSearchBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-8 rounded-xl border border-white/10">CLEAR</button>
            </div>
            <div class="flex flex-col sm:flex-row gap-x-8 gap-y-4 mt-5 text-sm font-medium">
                <div class="flex items-center group cursor-pointer">
                    <input type="checkbox" id="includeDigital" class="h-4 w-4 border-slate-300 rounded text-blue-600 focus:ring-blue-500/50 cursor-pointer">
                    <label for="includeDigital" class="ml-2 text-slate-400 group-hover:text-slate-200 transition-colors cursor-pointer">Include Digital</label>
                </div>
                <div class="flex items-center">
                    <label for="uniquenessFilter" class="mr-3 text-slate-400">Filter:</label>
                    <select id="uniquenessFilter" class="rounded-xl px-3 py-1 text-sm">
                        <option value="prints">All Prints</option>
                        <option value="cards">Base Set</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="loader" class="hidden justify-center items-center my-8">
            <div class="loader ease-linear rounded-full border-4 h-24 w-24"></div>
        </div>
        <div id="message-area" class="text-center font-mono text-purple-300 my-4 h-6 text-sm tracking-wide"></div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-2 order-2 lg:order-1">
                <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
                    <h2 class="text-3xl font-bold text-slate-100 flex items-center">
                        Results
                    </h2>
                    <div class="flex flex-col sm:flex-row gap-4 items-center w-full md:w-auto">
                         <input type="text" id="filterInput" class="rounded-xl px-4 py-2 w-full sm:w-64" placeholder="Filter by Name">
                        <select id="sortOrder" class="rounded-xl px-2 py-2 w-full sm:w-auto">
                            <option value="name_asc">Name (A-Z)</option>
                            <option value="name_desc">Name (Z-A)</option>
                            <option value="price_desc">Price (High)</option>
                            <option value="price_asc">Price (Low)</option>
                        </select>
                    </div>
                </div>
                <div id="searchResults" class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
                    </div>
                <div id="paginationControls" class="mt-8 flex justify-center items-center gap-6 hidden">
                    <button id="prevPageBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 border border-white/10 font-bold py-2 px-6 rounded-xl transition">PREV</button>
                    <span id="pageInfo" class="text-lg font-mono text-slate-400"></span>
                    <button id="nextPageBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 border border-white/10 font-bold py-2 px-6 rounded-xl transition">NEXT</button>
                </div>
            </div>

            <div class="order-1 lg:order-2">
                <div class="lg:sticky top-8">
                    <div class="clean-panel rounded-2xl p-6 border-t-4 border-t-purple-500">
                        <div class="mb-6">
                            <h2 class="text-2xl font-bold text-slate-100 mb-4 flex items-center justify-between">
                                Collection
                                <span class="text-xs font-mono text-purple-300 border border-purple-500/30 px-2 py-1 rounded bg-purple-500/10">Active</span>
                            </h2>
                            <div class="flex flex-col sm:flex-row gap-2 mb-2">
                                <select id="collectionSelector" class="flex-grow rounded-xl px-2 py-2"></select>
                                <select id="currency" class="rounded-xl px-2 py-2 mt-2 sm:mt-0 w-24">
                                    <option value="usd">USD</option>
                                    <option value="eur">EUR</option>
                                    <option value="tix">TIX</option>
                                </select>
                            </div>
                             <div class="flex flex-col gap-2">
                                <input type="text" id="newCollectionName" class="w-full rounded-xl px-4 py-2" placeholder="New collection name...">
                                <button id="createCollectionBtn" class="btn-clean bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-xl text-sm w-full">CREATE</button>
                            </div>
                            <div class="grid grid-cols-3 sm:grid-cols-3 gap-2 mt-4">
                                <button id="renameCollectionBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">RENAME</button>
                                <button id="updatePricesBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">SYNC</button>
                                <button id="importTxtBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">IMPORT</button>
                                <button id="exportTxtBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">EXPORT</button>
                                <button id="visualViewBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">GRID VIEW</button>
                                <button id="photoStudioBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-1 rounded-lg text-[10px] tracking-wider border border-white/10 whitespace-nowrap">MANIFEST</button>
                                <button id="ebayViewBtn" class="col-span-3 btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-xl text-xs border border-purple-500/30 whitespace-nowrap">LIST GENERATOR</button>
                            </div>
                        </div>

                        <div class="bg-white/5 rounded-xl p-4 border border-white/10 mb-4 font-mono">
                            <div class="flex justify-between items-center mb-1">
                                <p class="text-slate-500 text-xs">TOTAL VALUE</p>
                                <p id="totalValue" class="text-xl font-bold text-green-400">$0.00</p>
                            </div>
                            <div class="flex justify-between items-center">
                                <p class="text-slate-500 text-xs">TOTAL CARDS</p>
                                <p id="totalCards" class="text-xl font-bold text-slate-200">0</p>
                            </div>
                        </div>

                        <div id="inventory" class="space-y-3 max-h-[50vh] lg:max-h-[40vh] overflow-y-auto pr-2">
                            </div>

                        <div class="mt-6 pt-4 border-t border-white/10 flex flex-col sm:flex-row gap-4">
                            <button id="saveCollectionsBtn" class="flex-1 btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 rounded-xl text-xs">SAVE</button>
                            <button id="deleteCollectionBtn" class="flex-1 btn-clean bg-white/5 hover:bg-red-500/20 text-red-400 font-bold py-2 px-4 rounded-xl text-xs border border-red-500/20">DELETE</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="importModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-5 sm:p-8 w-full max-w-2xl border border-white/10 shadow-2xl max-h-[95vh] overflow-y-auto" style="background: rgba(20, 20, 35, 0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <h2 class="text-2xl font-bold mb-2 text-slate-100">Import Cards</h2>
            <p class="text-slate-400 mb-4 font-mono text-sm">Paste card list or upload a .txt file. Format: QTY CARDNAME. Scoped to current search set.</p>
            <div class="flex items-center gap-3 mb-3">
                <label class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 font-bold py-2 px-4 rounded-lg text-xs tracking-wider border border-white/10 cursor-pointer">
                    UPLOAD .TXT
                    <input type="file" id="importFileInput" accept=".txt" class="hidden">
                </label>
                <span id="importFileName" class="text-xs font-mono text-slate-500"></span>
            </div>
            <textarea id="importTextArea" class="w-full h-56 rounded-xl p-4 font-mono text-sm" placeholder="4x Sol Ring&#10;1x Black Lotus"></textarea>
            <div id="import-status" class="mt-4 text-sm h-6 text-purple-400 font-mono"></div>
            <div id="import-errors" class="mt-2 text-xs text-red-400 max-h-24 overflow-y-auto font-mono"></div>
            <div class="mt-6 flex justify-end gap-4">
                <button id="cancelImportBtn" class="btn-clean bg-white/5 hover:bg-white/10 text-slate-300 py-2 px-6 rounded-xl text-sm border border-white/10">CANCEL</button>
                <button id="processImportBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-6 rounded-xl text-sm">IMPORT</button>
            </div>
        </div>
    </div>

    <div id="visualViewModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div id="visualViewContent" class="rounded-2xl p-4 sm:p-6 w-full max-w-7xl h-[95vh] sm:h-[90vh] flex flex-col border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center mb-4 sm:mb-6">
                <h2 class="text-lg sm:text-2xl font-bold text-slate-100">Visual Grid</h2>
                <div class="flex items-center gap-4">
                    <button id="fullscreenBtn" title="Fullscreen" class="text-slate-400 hover:text-purple-400 transition-colors hidden sm:block">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                    </button>
                    <button id="exitFullscreenBtn" title="Exit Fullscreen" class="text-slate-400 hover:text-purple-400 hidden transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
                    </button>
                    <button id="closeVisualViewBtn" class="text-slate-500 hover:text-red-400 text-4xl leading-none">&times;</button>
                </div>
            </div>
            <div id="visual-view-body" class="flex-grow overflow-y-auto pr-2">
                <div id="visual-view-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                    </div>
            </div>
        </div>
    </div>

    <div id="photoStudioModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-1 sm:p-4">
        <div class="rounded-2xl p-0 w-full max-w-[95vw] h-[98vh] sm:h-[95vh] flex flex-col border border-white/10 shadow-2xl overflow-hidden" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex justify-between items-center p-3 sm:p-4 border-b border-white/10 gap-3" style="background: rgba(20, 20, 35, 0.8);">
                <div class="flex items-center min-w-0">
                    <h2 class="text-base sm:text-2xl font-bold text-slate-100 tracking-wider truncate">Manifest</h2>
                    <span class="ml-3 text-xs font-mono text-slate-500 hidden md:inline">Image Generator</span>
                </div>

                <div class="flex gap-3 flex-shrink-0">
                    <button id="downloadPhotoBtn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 sm:px-6 rounded-xl text-xs sm:text-sm tracking-wide shadow-sm transition-colors whitespace-nowrap">DOWNLOAD</button>
                    <button id="closePhotoStudioBtn" class="text-slate-500 hover:text-red-400 text-3xl leading-none">&times;</button>
                </div>
            </div>

            <div id="photo-viewport">
                <div id="photo-stage">
                    </div>
            </div>
        </div>
    </div>

    <div id="ebayViewModal" class="modal-overlay hidden fixed inset-0 z-50 flex items-center justify-center p-2 sm:p-4">
        <div class="rounded-2xl p-4 sm:p-6 w-full max-w-6xl h-[95vh] sm:h-[90vh] flex flex-col border border-white/10 shadow-2xl" style="background: rgba(15, 15, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 flex-shrink-0 border-b border-white/10 pb-4 gap-3">
                <div class="flex items-center justify-between w-full sm:w-auto">
                    <h2 class="text-lg sm:text-2xl font-bold text-slate-100 tracking-wider">List Generator</h2>
                    <button id="closeEbayViewBtn" class="text-slate-500 hover:text-red-400 text-3xl ml-2 sm:hidden">&times;</button>
                </div>
                <div class="flex gap-3 items-center w-full sm:w-auto">
                    <div class="flex items-center px-3 py-2 bg-white/5 rounded-lg border border-white/10">
                        <input type="checkbox" id="ebaySelectAll" class="h-4 w-4 rounded mr-2">
                        <label for="ebaySelectAll" class="text-sm font-mono text-slate-400 whitespace-nowrap">Select All</label>
                    </div>
                    <button id="copyEbayBtn" class="btn-clean bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 sm:px-6 rounded-xl text-sm tracking-wide flex-grow sm:flex-grow-0">COPY</button>
                    <button class="ebay-close-desktop text-slate-500 hover:text-red-400 text-3xl ml-2 hidden sm:block">&times;</button>
                </div>
            </div>

            <div id="ebay-view-body" class="flex-grow overflow-y-auto bg-white/5 p-3 sm:p-6 border border-white/10 rounded-xl">
                <div id="ebayListContainer" class="checklist-container">
                    </div>
            </div>

            <div class="mt-3 text-slate-500 text-xs text-right flex-shrink-0 font-mono">
                Format: [QTY]x MTG [SET] [NAME] #[ID]
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // UI Elements
            const searchBtn = document.getElementById('searchBtn');
            const clearSearchBtn = document.getElementById('clearSearchBtn');
            const setCodeInput = document.getElementById('setCode');
            const searchResultsContainer = document.getElementById('searchResults');
            const inventoryContainer = document.getElementById('inventory');
            const totalValueEl = document.getElementById('totalValue');
            const totalCardsEl = document.getElementById('totalCards');
            const loader = document.getElementById('loader');
            const messageArea = document.getElementById('message-area');
            const currencySelect = document.getElementById('currency');
            const collectionSelector = document.getElementById('collectionSelector');
            const newCollectionNameInput = document.getElementById('newCollectionName');
            const createCollectionBtn = document.getElementById('createCollectionBtn');
            const renameCollectionBtn = document.getElementById('renameCollectionBtn');
            const updatePricesBtn = document.getElementById('updatePricesBtn');
            const importTxtBtn = document.getElementById('importTxtBtn');
            const exportTxtBtn = document.getElementById('exportTxtBtn');
            const visualViewBtn = document.getElementById('visualViewBtn');
            const photoStudioBtn = document.getElementById('photoStudioBtn');
            const ebayViewBtn = document.getElementById('ebayViewBtn');
            const saveCollectionsBtn = document.getElementById('saveCollectionsBtn');
            const deleteCollectionBtn = document.getElementById('deleteCollectionBtn');
            const includeDigitalCheckbox = document.getElementById('includeDigital');
            const uniquenessFilter = document.getElementById('uniquenessFilter');
            const sortOrderSelect = document.getElementById('sortOrder');
            const filterInput = document.getElementById('filterInput');

            // Pagination UI
            const paginationControls = document.getElementById('paginationControls');
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');

            // Modal UI Elements
            const importModal = document.getElementById('importModal');
            const importTextArea = document.getElementById('importTextArea');
            const importFileInput = document.getElementById('importFileInput');
            const importFileName = document.getElementById('importFileName');
            const importStatus = document.getElementById('import-status');
            const importErrors = document.getElementById('import-errors');
            const cancelImportBtn = document.getElementById('cancelImportBtn');
            const processImportBtn = document.getElementById('processImportBtn');

            // Visual View Modal
            const visualViewModal = document.getElementById('visualViewModal');
            const visualViewContent = document.getElementById('visualViewContent');
            const closeVisualViewBtn = document.getElementById('closeVisualViewBtn');
            const visualViewGrid = document.getElementById('visual-view-grid');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');

            // Manifest / Photo Studio Modal
            const photoStudioModal = document.getElementById('photoStudioModal');
            const closePhotoStudioBtn = document.getElementById('closePhotoStudioBtn');
            const photoStage = document.getElementById('photo-stage');
            const downloadPhotoBtn = document.getElementById('downloadPhotoBtn');

            // eBay View Modal
            const ebayViewModal = document.getElementById('ebayViewModal');
            const closeEbayViewBtn = document.getElementById('closeEbayViewBtn');
            const ebayListContainer = document.getElementById('ebayListContainer');
            const ebaySelectAll = document.getElementById('ebaySelectAll');
            const copyEbayBtn = document.getElementById('copyEbayBtn');

            // App State
            let collections = {};
            let activeCollectionName = '';
            let currentCurrency = 'usd';
            let currentSearchResults = [];
            let currentPage = 1;
            const cardsPerPage = 20;

            // Load collections from local storage on page load
            loadCollections();

            // Event Listeners
            searchBtn.addEventListener('click', searchBySetCode);
            clearSearchBtn.addEventListener('click', clearSearchResults);
            setCodeInput.addEventListener('keypress', (e) => e.key === 'Enter' && searchBySetCode());
            saveCollectionsBtn.addEventListener('click', saveCollections);
            deleteCollectionBtn.addEventListener('click', deleteCollection);
            createCollectionBtn.addEventListener('click', createCollection);
            newCollectionNameInput.addEventListener('keypress', (e) => e.key === 'Enter' && createCollection());
            renameCollectionBtn.addEventListener('click', renameCollection);
            updatePricesBtn.addEventListener('click', updateCollectionPrices);
            importTxtBtn.addEventListener('click', openImportModal);
            exportTxtBtn.addEventListener('click', exportCollectionToTxt);
            visualViewBtn.addEventListener('click', openVisualViewModal);
            photoStudioBtn.addEventListener('click', openManifestGenerator);
            ebayViewBtn.addEventListener('click', openEbayViewModal);
            collectionSelector.addEventListener('change', switchCollection);
            uniquenessFilter.addEventListener('change', () => {
                if (setCodeInput.value.trim()) {
                    searchBySetCode();
                }
            });
            currencySelect.addEventListener('change', (e) => {
                currentCurrency = e.target.value;
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
            });
            sortOrderSelect.addEventListener('change', () => {
                currentPage = 1;
                filterAndSortAndDisplayResults();
            });
            filterInput.addEventListener('input', () => {
                currentPage = 1;
                filterAndSortAndDisplayResults();
                filterInventory();
            });
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    filterAndSortAndDisplayResults();
                }
            });
            nextPageBtn.addEventListener('click', () => {
                currentPage++;
                filterAndSortAndDisplayResults();
            });

            cancelImportBtn.addEventListener('click', () => importModal.classList.add('hidden'));
            processImportBtn.addEventListener('click', processImport);
            importFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                importFileName.textContent = file.name;
                const reader = new FileReader();
                reader.onload = (ev) => { importTextArea.value = ev.target.result; };
                reader.readAsText(file);
            });

            // Visual View Listeners
            closeVisualViewBtn.addEventListener('click', () => visualViewModal.classList.add('hidden'));
            fullscreenBtn.addEventListener('click', () => visualViewContent.requestFullscreen());
            exitFullscreenBtn.addEventListener('click', () => document.exitFullscreen());
            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    fullscreenBtn.classList.add('hidden');
                    exitFullscreenBtn.classList.remove('hidden');
                } else {
                    fullscreenBtn.classList.remove('hidden');
                    exitFullscreenBtn.classList.add('hidden');
                }
            });

            // Photo Studio Listeners
            closePhotoStudioBtn.addEventListener('click', () => photoStudioModal.classList.add('hidden'));
            downloadPhotoBtn.addEventListener('click', generateAndDownloadPhoto);

            // eBay View Listeners
            closeEbayViewBtn.addEventListener('click', () => ebayViewModal.classList.add('hidden'));
            document.querySelector('.ebay-close-desktop')?.addEventListener('click', () => ebayViewModal.classList.add('hidden'));
            ebaySelectAll.addEventListener('change', (e) => {
                const checkboxes = ebayListContainer.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            });
            copyEbayBtn.addEventListener('click', copyEbayListToClipboard);


            /**
             * Fetches cards from the Scryfall API based on one or more set codes.
             */
            async function searchBySetCode() {
                const setCodesInput = setCodeInput.value.trim().toLowerCase();
                const setCodes = setCodesInput.split(',')
                    .map(code => code.trim())
                    .filter(code => code.length >= 3);

                if (setCodes.length === 0) {
                    showMessage('Enter a set code to search');
                    return;
                }

                showLoader(true);
                showMessage('Searching Scryfall...');
                searchResultsContainer.innerHTML = '';
                currentSearchResults = [];
                filterInput.value = '';
                paginationControls.classList.add('hidden');
                currentPage = 1;

                try {
                    const includeDigital = includeDigitalCheckbox.checked;
                    const setQuery = setCodes.map(code => `set%3A${code}`).join('+OR+');
                    let searchParams = `(${setQuery})`;

                    if (!includeDigital) {
                        searchParams += '+not%3Adigital';
                    }

                    const uniqueness = uniquenessFilter.value;
                    let allCards = [];
                    let nextPageUrl = `https://api.scryfall.com/cards/search?unique=${uniqueness}&q=${searchParams}`;

                    while (nextPageUrl) {
                        const response = await fetch(nextPageUrl);
                        if (!response.ok) {
                             if (response.status === 404) throw new Error(`Set not found`);
                            throw new Error(`HTTP error: ${response.status}`);
                        }
                        const data = await response.json();
                        allCards = allCards.concat(data.data);
                        nextPageUrl = data.has_more ? data.next_page : null;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    currentSearchResults = allCards;
                    filterAndSortAndDisplayResults();
                } catch (error) {
                    console.error('Error fetching data from Scryfall:', error);
                    showMessage(`Search failed: ${error.message}`);
                } finally {
                    showLoader(false);
                    if(currentSearchResults.length > 0) showMessage('');
                }
            }

            function clearSearchResults() {
                searchResultsContainer.innerHTML = '';
                currentSearchResults = [];
                setCodeInput.value = '';
                filterInput.value = '';
                showMessage('');
                paginationControls.classList.add('hidden');
                filterInventory();
            }

            function filterAndSortAndDisplayResults() {
                const filterText = filterInput.value.toLowerCase();
                let filteredResults = currentSearchResults;

                if (filterText) {
                    filteredResults = currentSearchResults.filter(card =>
                        card.name.toLowerCase().includes(filterText)
                    );
                }

                const sortOrder = sortOrderSelect.value;
                filteredResults.sort((a, b) => {
                    switch (sortOrder) {
                        case 'name_asc':
                            return a.name.localeCompare(b.name);
                        case 'name_desc':
                            return b.name.localeCompare(a.name);
                        case 'price_desc':
                            const priceA_desc = parseFloat(a.prices[currentCurrency]) || 0;
                            const priceB_desc = parseFloat(b.prices[currentCurrency]) || 0;
                            return priceB_desc - priceA_desc;
                        case 'price_asc':
                            const priceA_asc = parseFloat(a.prices[currentCurrency]) || Infinity;
                            const priceB_asc = parseFloat(b.prices[currentCurrency]) || Infinity;
                            return priceA_asc - priceB_asc;
                        default:
                            return 0;
                    }
                });

                displaySearchResults(filteredResults);
                updatePaginationControls(filteredResults.length);
            }

            function displaySearchResults(cards) {
                searchResultsContainer.innerHTML = '';

                const startIndex = (currentPage - 1) * cardsPerPage;
                const endIndex = startIndex + cardsPerPage;
                const paginatedCards = cards.slice(startIndex, endIndex);

                if (paginatedCards.length === 0 && (setCodeInput.value.trim() !== '' || filterInput.value.trim() !== '')) {
                    showMessage('No results match filter');
                    return;
                }

                paginatedCards.forEach(card => {
                    const price = card.prices[currentCurrency] || 'N/A';
                    const foilPrice = card.prices[`${currentCurrency}_foil`] || 'N/A';

                    const inventory = collections[activeCollectionName] || [];
                    const inventoryCardNormal = inventory.find(item => item.id === card.id && !item.isFoil);
                    const inventoryCardFoil = inventory.find(item => item.id === card.id && item.isFoil);
                    const quantityNormal = inventoryCardNormal ? inventoryCardNormal.quantity : 0;
                    const quantityFoil = inventoryCardFoil ? inventoryCardFoil.quantity : 0;

                    const cardElement = document.createElement('div');
                    cardElement.className = 'card rounded-lg overflow-hidden flex flex-col';
                    cardElement.setAttribute('data-card-id', card.id);
                    cardElement.innerHTML = `
                        <div class="relative">
                            <img src="${getCardImage(card, 'normal')}" alt="${card.name}" class="w-full h-auto" onerror="this.onerror=null;this.src='https://placehold.co/223x310/1a1a2e/8b5cf6?text=No+Image';">
                        </div>
                        <div class="p-3 sm:p-4 flex-grow flex flex-col justify-between">
                            <h3 class="font-bold text-sm sm:text-base truncate text-slate-100 font-mono tracking-tighter">${card.name}</h3>
                            <div class="mt-3 space-y-2">
                                <div class="flex items-center justify-between">
                                    <p class="text-xs text-slate-400 font-mono">Reg: <span class="text-green-400">${getCurrencySymbol()}${price}</span></p>
                                    <div class="flex items-center gap-1">
                                        <button class="remove-one-btn quantity-btn flex items-center justify-center bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 rounded text-red-400 font-bold transition-all text-xs" data-foil="false">-</button>
                                        <span class="quantity-display-normal font-bold text-sm w-6 text-center font-mono text-slate-200">${quantityNormal}</span>
                                        <button class="add-one-btn quantity-btn flex items-center justify-center bg-green-500/10 hover:bg-green-500/20 border border-green-500/20 rounded text-green-400 font-bold transition-all text-xs" data-foil="false">+</button>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between border-t border-white/5 pt-2">
                                    <p class="text-xs text-slate-400 font-mono">Foil: <span class="text-amber-400">${getCurrencySymbol()}${foilPrice}</span></p>
                                    <div class="flex items-center gap-1">
                                        <button class="remove-one-btn quantity-btn flex items-center justify-center bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 rounded text-red-400 font-bold transition-all text-xs" data-foil="true">-</button>
                                        <span class="quantity-display-foil font-bold text-sm w-6 text-center font-mono text-amber-400">${quantityFoil}</span>
                                        <button class="add-one-btn quantity-btn flex items-center justify-center bg-green-500/10 hover:bg-green-500/20 border border-green-500/20 rounded text-green-400 font-bold transition-all text-xs" data-foil="true">+</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    cardElement.querySelectorAll('.add-one-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (!activeCollectionName) { showMessage("No active collection"); return; }
                            const isFoil = btn.dataset.foil === 'true';
                            addToInventory(card, 1, isFoil);
                        });
                    });

                    cardElement.querySelectorAll('.remove-one-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (!activeCollectionName) { showMessage("No active collection"); return; }
                            const isFoil = btn.dataset.foil === 'true';
                            removeFromInventory(card.id, isFoil);
                        });
                    });

                    searchResultsContainer.appendChild(cardElement);
                });
            }

            function updatePaginationControls(totalCards) {
                if (totalCards <= cardsPerPage) {
                    paginationControls.classList.add('hidden');
                    return;
                }

                paginationControls.classList.remove('hidden');
                const totalPages = Math.ceil(totalCards / cardsPerPage);
                pageInfo.textContent = `Page ${currentPage} / ${totalPages}`;

                prevPageBtn.disabled = currentPage === 1;
                nextPageBtn.disabled = currentPage === totalPages;
            }

            function updateCardQuantityInSearchResults(cardId) {
                const cardElements = searchResultsContainer.querySelectorAll(`[data-card-id="${cardId}"]`);
                cardElements.forEach(cardElement => {
                    const inventory = collections[activeCollectionName] || [];
                    const inventoryCardNormal = inventory.find(item => item.id === cardId && !item.isFoil);
                    const inventoryCardFoil = inventory.find(item => item.id === cardId && item.isFoil);

                    cardElement.querySelector('.quantity-display-normal').textContent = inventoryCardNormal ? inventoryCardNormal.quantity : 0;
                    cardElement.querySelector('.quantity-display-foil').textContent = inventoryCardFoil ? inventoryCardFoil.quantity : 0;
                });
            }

            function addToInventory(card, quantityToAdd, isFoil) {
                const currentInventory = collections[activeCollectionName];
                const inventoryId = card.id + (isFoil ? '_foil' : '_normal');
                const existingCard = currentInventory.find(item => item.inventoryId === inventoryId);

                if (existingCard) {
                    existingCard.quantity += quantityToAdd;
                } else {
                    currentInventory.push({ ...card, quantity: quantityToAdd, isFoil: isFoil, inventoryId: inventoryId });
                }

                updateInventoryDisplay();
                updateCardQuantityInSearchResults(card.id);
            }

            function removeFromInventory(cardId, isFoil) {
                const currentInventory = collections[activeCollectionName];
                const inventoryId = cardId + (isFoil ? '_foil' : '_normal');
                const cardIndex = currentInventory.findIndex(item => item.inventoryId === inventoryId);

                if (cardIndex > -1) {
                    currentInventory[cardIndex].quantity--;
                    if (currentInventory[cardIndex].quantity === 0) {
                        currentInventory.splice(cardIndex, 1);
                    }
                    updateInventoryDisplay();
                    updateCardQuantityInSearchResults(cardId);
                }
            }

            function updateInventoryDisplay() {
                inventoryContainer.innerHTML = '';
                let totalValue = 0;
                let totalCards = 0;
                const currentInventory = collections[activeCollectionName];

                if (!currentInventory || currentInventory.length === 0) {
                    inventoryContainer.innerHTML = '<p class="text-slate-500 font-mono text-sm text-center py-4">No cards in collection</p>';
                    totalValueEl.textContent = `${getCurrencySymbol()}0.00`;
                    totalCardsEl.textContent = '0';
                    return;
                }

                currentInventory.sort((a,b) => a.name.localeCompare(b.name) || (a.isFoil - b.isFoil));

                currentInventory.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    totalValue += price * card.quantity;
                    totalCards += card.quantity;
                    const inventoryItem = document.createElement('div');
                    inventoryItem.className = 'inventory-item flex items-center justify-between bg-white/5 p-2 rounded-lg border border-white/10 hover:border-purple-500/30 transition-colors group';
                    inventoryItem.dataset.cardName = card.name.toLowerCase();

                    const foilBadge = card.isFoil ? '<span class="text-amber-400 font-bold ml-1 text-xs tracking-wider">[FOIL]</span>' : '';

                    inventoryItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden">
                            <div class="w-8 h-8 rounded bg-cover bg-center flex-shrink-0 border border-white/10" style="background-image: url('${getCardImage(card, 'small')}');"></div>
                            <div class="min-w-0">
                                <p class="font-semibold text-slate-300 truncate text-sm font-mono group-hover:text-slate-100 transition-colors">${card.name} ${foilBadge}</p>
                                <p class="text-xs text-slate-500 font-mono">${getCurrencySymbol()}${price.toFixed(2)} x ${card.quantity}</p>
                            </div>
                        </div>
                        <button class="remove-from-inventory-btn bg-white/5 hover:bg-red-500/20 text-red-400 hover:text-red-300 font-bold py-1 px-3 rounded-lg text-xs transition-colors border border-red-500/20" data-card-id="${card.id}" data-foil="${card.isFoil}">DEL</button>
                    `;
                    inventoryItem.querySelector('.remove-from-inventory-btn').addEventListener('click', (e) => {
                        const isFoil = e.target.dataset.foil === 'true';
                        removeFromInventory(e.target.dataset.cardId, isFoil);
                    });
                    inventoryContainer.appendChild(inventoryItem);
                });

                totalValueEl.textContent = `${getCurrencySymbol()}${totalValue.toFixed(2)}`;
                totalCardsEl.textContent = totalCards;
                filterInventory();
            }

            function filterInventory() {
                const filterText = filterInput.value.toLowerCase();
                const inventoryItems = inventoryContainer.querySelectorAll('.inventory-item');
                inventoryItems.forEach(item => {
                    const cardName = item.dataset.cardName;
                    if (cardName.includes(filterText)) {
                        item.classList.remove('hidden');
                    } else {
                        item.classList.add('hidden');
                    }
                });
            }

            function saveCollections() {
                localStorage.setItem('mtgCollections', JSON.stringify(collections));
                showMessage('Saved to local storage');
            }

            async function loadCollections() {
                const savedCollections = localStorage.getItem('mtgCollections');
                if (savedCollections) {
                    collections = JSON.parse(savedCollections);
                } else {
                    collections = { 'Main Collection': [] };
                }

                const needsSave = await migrateCollections(collections);
                if (needsSave) {
                    saveCollections();
                }

                if (Object.keys(collections).length > 0) {
                    activeCollectionName = Object.keys(collections)[0];
                } else {
                    collections = { 'Main Collection': [] };
                    activeCollectionName = 'Main Collection';
                }

                updateCollectionSelector();
                updateInventoryDisplay();
            }

            async function updateCollectionPrices() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }

                const collection = collections[activeCollectionName];
                const ids = [...new Set(collection.map(c => c.id))].map(id => ({ id }));

                showLoader(true);
                showMessage("Syncing prices...");

                try {
                    const fullCardDataMap = new Map();
                    const CHUNK_SIZE = 75;

                    for (let i = 0; i < ids.length; i += CHUNK_SIZE) {
                        const chunk = ids.slice(i, i + CHUNK_SIZE);
                        const response = await fetch('https://api.scryfall.com/cards/collection', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ identifiers: chunk })
                        });

                        if (!response.ok) throw new Error("API connection failed");
                        const result = await response.json();
                        result.data.forEach(card => fullCardDataMap.set(card.id, card));

                        await new Promise(r => setTimeout(r, 100));
                    }

                    collections[activeCollectionName] = collection.map(oldCard => {
                        if (fullCardDataMap.has(oldCard.id)) {
                            const newCardData = fullCardDataMap.get(oldCard.id);
                            return {
                                ...newCardData,
                                quantity: oldCard.quantity,
                                isFoil: oldCard.isFoil,
                                inventoryId: oldCard.inventoryId
                            };
                        }
                        return oldCard;
                    });

                    saveCollections();
                    updateInventoryDisplay();
                    showMessage("Prices updated");
                } catch (e) {
                    console.error(e);
                    showMessage("Update failed â€” check connection");
                } finally {
                    showLoader(false);
                }
            }

            async function migrateCollections(collectionsToMigrate) {
                let identifiersToFetch = [];
                for (const collectionName in collectionsToMigrate) {
                    collectionsToMigrate[collectionName].forEach(card => {
                        if (!card.image_uris && card.id) {
                            identifiersToFetch.push({ id: card.id });
                        }
                    });
                }

                if (identifiersToFetch.length === 0) {
                    return false;
                }

                const uniqueIdentifiers = [...new Map(identifiersToFetch.map(item => [item.id, item])).values()];
                const fullCardDataMap = new Map();
                const CHUNK_SIZE = 75;

                showMessage("Migrating data...");
                try {
                    for (let i = 0; i < uniqueIdentifiers.length; i += CHUNK_SIZE) {
                        const chunk = uniqueIdentifiers.slice(i, i + CHUNK_SIZE);
                        const response = await fetch('https://api.scryfall.com/cards/collection', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ identifiers: chunk })
                        });

                        if (!response.ok) {
                            throw new Error(`API error: ${response.status}`);
                        }
                        const result = await response.json();
                        if (result.data) {
                            result.data.forEach(card => fullCardDataMap.set(card.id, card));
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    for (const collectionName in collectionsToMigrate) {
                        collectionsToMigrate[collectionName] = collectionsToMigrate[collectionName].map(card => {
                            if (!card.image_uris && fullCardDataMap.has(card.id)) {
                                const fullCardData = fullCardDataMap.get(card.id);
                                const { quantity, isFoil, inventoryId } = card;
                                return { ...fullCardData, quantity, isFoil, inventoryId };
                            }
                            return card;
                        });
                    }
                    showMessage("Migration complete");
                    return true;
                } catch (error) {
                    console.error("Failed to migrate collection data:", error);
                    showMessage("Migration error â€” check console");
                    return false;
                }
            }

            function createCollection() {
                const newName = newCollectionNameInput.value.trim();
                if (newName && !collections[newName]) {
                    collections[newName] = [];
                    activeCollectionName = newName;
                    newCollectionNameInput.value = '';
                    updateCollectionSelector();
                    updateInventoryDisplay();
                    showMessage(`Collection "${newName}" created`);
                } else if (collections[newName]) {
                    showMessage('Collection already exists');
                } else {
                    showMessage('Enter a collection name');
                }
            }

            function renameCollection() {
                if (!activeCollectionName) {
                    showMessage("Select a collection first");
                    return;
                }
                const newName = prompt(`Rename "${activeCollectionName}" to:`, activeCollectionName);
                if (newName && newName.trim() !== '' && newName !== activeCollectionName) {
                    if (collections[newName]) {
                        showMessage(`"${newName}" already exists`);
                        return;
                    }
                    Object.defineProperty(collections, newName,
                        Object.getOwnPropertyDescriptor(collections, activeCollectionName));
                    delete collections[activeCollectionName];

                    activeCollectionName = newName;
                    updateCollectionSelector();
                    showMessage(`Renamed to "${newName}"`);
                    saveCollections();
                }
            }

            function exportCollectionToTxt() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Nothing to export");
                    return;
                }

                const collection = collections[activeCollectionName];
                let totalCards = 0;
                let totalValue = 0;
                let txtContent = `${activeCollectionName}\n`;

                collection.forEach(card => {
                    totalCards += card.quantity;
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    totalValue += price * card.quantity;
                });

                txtContent += `Total Cards: ${totalCards}\n`;
                txtContent += `Total Value: ${getCurrencySymbol()}${totalValue.toFixed(2)}\n\n`;

                collection.forEach(card => {
                    const setCode = card.set ? card.set.toUpperCase() : '';
                    const collectorNumber = card.collector_number || '';
                    const rarity = card.rarity ? card.rarity.charAt(0).toUpperCase() + card.rarity.slice(1) : '';
                    const foilText = card.isFoil ? ' (Foil)' : '';
                    const price = parseFloat(card.isFoil ? card.prices[currentCurrency + '_foil'] : card.prices[currentCurrency]) || 0;
                    const formattedPrice = `${getCurrencySymbol()}${price.toFixed(2)}`;

                    let details = [];
                    if (setCode) details.push(setCode);
                    if (collectorNumber) details.push(`#${collectorNumber}`);
                    if (rarity) details.push(rarity);

                    let detailsString = details.length > 0 ? ` (${details.join(' - ')})` : '';

                    txtContent += `${card.quantity}x ${card.name}${foilText}${detailsString} - ${formattedPrice}\n`;
                });

                const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
                const safeFileName = activeCollectionName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `${safeFileName}_data.txt`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                showMessage("Exported to file");
            }

            function deleteCollection() {
                const collectionNames = Object.keys(collections);
                if (collectionNames.length === 0 || !activeCollectionName) {
                    showMessage("No collection to delete");
                    return;
                }
                if (confirm(`Delete "${activeCollectionName}"? This cannot be undone.`)) {
                    delete collections[activeCollectionName];
                    const remainingNames = Object.keys(collections);
                    if (remainingNames.length > 0) {
                        activeCollectionName = remainingNames[0];
                    } else {
                        collections = { 'Main Collection': [] };
                        activeCollectionName = 'Main Collection';
                    }
                    updateCollectionSelector();
                    updateInventoryDisplay();
                    showMessage(`Collection deleted`);
                    saveCollections();
                }
            }

            function switchCollection(e) {
                activeCollectionName = e.target.value;
                updateInventoryDisplay();
                filterAndSortAndDisplayResults();
            }

            function updateCollectionSelector() {
                collectionSelector.innerHTML = '';
                Object.keys(collections).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === activeCollectionName) {
                        option.selected = true;
                    }
                    collectionSelector.appendChild(option);
                });
            }

            function getCardImage(card, size = 'normal') {
                const placeholderUrl = size === 'small'
                    ? 'https://placehold.co/146x204/1a1a2e/8b5cf6?text=No+Image'
                    : 'https://placehold.co/223x310/1a1a2e/8b5cf6?text=No+Image';

                if (card.image_uris && card.image_uris[size]) {
                    return card.image_uris[size];
                }

                if (card.card_faces && card.card_faces.length > 0 && card.card_faces[0].image_uris && card.card_faces[0].image_uris[size]) {
                    return card.card_faces[0].image_uris[size];
                }

                return placeholderUrl;
            }

            function getCurrencySymbol() {
                switch (currentCurrency) {
                    case 'eur': return '\u20AC';
                    case 'tix': return 'TIX ';
                    default: return '$';
                }
            }

            function showLoader(isLoading) {
                loader.classList.toggle('hidden', !isLoading);
                loader.classList.toggle('flex', isLoading);
            }

            function showMessage(text) {
                messageArea.textContent = text;
                if (text) {
                    setTimeout(() => messageArea.textContent = '', 3000);
                }
            }

            function openVisualViewModal() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }
                const collection = collections[activeCollectionName];
                const uniqueCardsMap = new Map();
                collection.forEach(card => {
                    if (uniqueCardsMap.has(card.id)) {
                        const existing = uniqueCardsMap.get(card.id);
                        existing.totalQuantity += card.quantity;
                        uniqueCardsMap.set(card.id, existing);
                    } else {
                        uniqueCardsMap.set(card.id, { cardData: card, totalQuantity: card.quantity });
                    }
                });
                const uniqueCards = Array.from(uniqueCardsMap.values()).sort((a, b) => a.cardData.name.localeCompare(b.cardData.name));
                visualViewGrid.innerHTML = '';
                if (uniqueCards.length === 0) {
                    visualViewGrid.innerHTML = '<p class="col-span-full text-center text-slate-500">No cards to display</p>';
                } else {
                    uniqueCards.forEach(item => {
                        const card = item.cardData;
                        const totalQuantity = item.totalQuantity;
                        const container = document.createElement('div');
                        container.className = 'relative group';
                        const img = document.createElement('img');
                        img.src = getCardImage(card, 'normal');
                        img.className = 'w-full h-auto rounded-lg border border-transparent group-hover:border-purple-500/40 transition-all';
                        const quantityBadge = document.createElement('div');
                        quantityBadge.className = 'absolute top-0 right-0 bg-black/70 text-slate-200 text-sm font-bold px-2 py-1 rounded-bl-lg border-l border-b border-white/10 backdrop-blur-sm';
                        quantityBadge.textContent = `${totalQuantity}`;
                        container.appendChild(img);
                        container.appendChild(quantityBadge);
                        visualViewGrid.appendChild(container);
                    });
                }
                visualViewModal.classList.remove('hidden');
            }

            // --- MANIFEST GENERATOR LOGIC (REVISED 2.0) ---
            function openManifestGenerator() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }

                const collection = collections[activeCollectionName];

                // Consolidate duplicates
                const uniqueMap = new Map();
                collection.forEach(card => {
                    const key = card.id + (card.isFoil ? '_foil' : '_norm');
                    if (uniqueMap.has(key)) {
                        uniqueMap.get(key).quantity += card.quantity;
                    } else {
                        uniqueMap.set(key, { ...card });
                    }
                });
                const sortedCollection = Array.from(uniqueMap.values());

                // Sort by Value High->Low for Highlights
                const valueSorted = [...sortedCollection].sort((a, b) => {
                    const priceA = parseFloat(a.isFoil ? a.prices[`${currentCurrency}_foil`] : a.prices[currentCurrency]) || 0;
                    const priceB = parseFloat(b.isFoil ? b.prices[`${currentCurrency}_foil`] : b.prices[currentCurrency]) || 0;
                    return priceB - priceA;
                });

                // --- BUILD HTML ---
                const totalVal = totalValueEl.textContent;
                const totalCnt = totalCardsEl.textContent;
                const dateStr = new Date().toLocaleDateString();

                // 1. Header
                let html = `
                    <div class="manifest-header">
                        <div>
                            <h2 class="text-3xl font-bold text-gray-900 tracking-tight mb-1">${activeCollectionName.toUpperCase()}</h2>
                            <p class="text-sm text-gray-500 font-mono">INVENTORY MANIFEST // ${dateStr}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-xs text-gray-500 font-mono mb-1 uppercase tracking-widest">Est. Market Value</p>
                            <p class="text-4xl font-bold text-slate-800 tracking-tighter">${totalVal}</p>
                            <p class="text-xs text-gray-400 mt-1">${totalCnt} ITEMS</p>
                        </div>
                    </div>
                `;

                // 2. High Value Grid (Top 4)
                html += `<div class="manifest-highlights"><p class="text-xs font-bold text-gray-400 mb-4 uppercase tracking-widest">Premium Assets</p><div class="highlight-grid">`;

                const topItems = valueSorted.slice(0, 4);
                topItems.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    html += `
                        <div class="highlight-card">
                            <div class="highlight-img-container">
                                <img src="${getCardImage(card, 'normal')}?cb=1" crossOrigin="anonymous" onerror="this.onerror=null;this.style.display='none';">
                            </div>
                            <div class="w-full">
                                <p class="text-xs font-bold text-gray-800 truncate w-full">${card.name}</p>
                                <p class="text-xs text-green-600 font-mono mt-1">${getCurrencySymbol()}${price.toFixed(2)}</p>
                            </div>
                        </div>
                    `;
                });

                for(let i=topItems.length; i<4; i++) {
                     html += `<div class="highlight-card opacity-0"></div>`;
                }

                html += `</div></div>`;

                // 3. The Full List
                html += `<div class="manifest-list-container">`;

                // Sort Alphabetically
                const alphaCollection = [...sortedCollection].sort((a,b) => a.name.localeCompare(b.name));

                alphaCollection.forEach(card => {
                    const price = parseFloat(card.isFoil ? card.prices[`${currentCurrency}_foil`] : card.prices[currentCurrency]) || 0;
                    const foilLabel = card.isFoil ? '<span class="text-amber-600 text-[10px] font-bold border border-amber-200 px-1 rounded ml-1">FOIL</span>' : '';
                    const setDisplay = card.set ? card.set.toUpperCase() : '---';
                    const collectorNumber = card.collector_number ? `#${card.collector_number}` : '';

                    html += `
                        <div class="manifest-row">
                            <div class="flex items-baseline overflow-hidden w-full">
                                <span class="font-mono font-bold text-gray-400 w-6 flex-shrink-0 text-right mr-2">${card.quantity}x</span>
                                <span class="font-semibold text-slate-700 truncate flex-grow">${card.name}</span>
                                ${foilLabel}
                            </div>
                            <div class="flex items-baseline flex-shrink-0 ml-2">
                                <span class="text-[11px] text-gray-400 font-mono mr-3 whitespace-nowrap">${setDisplay} ${collectorNumber}</span>
                                <span class="font-mono text-slate-600 text-xs w-14 text-right">${getCurrencySymbol()}${price.toFixed(2)}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;

                // 4. Footer
                html += `
                    <div class="bg-gray-100 p-4 border-t border-gray-200 text-center">
                         <p class="text-xs text-gray-400 font-mono">GENERATED BY MTG CARD VAULT</p>
                    </div>
                `;

                photoStage.innerHTML = html;
                photoStudioModal.classList.remove('hidden');
            }

            async function generateAndDownloadPhoto() {
                const btnOriginalText = downloadPhotoBtn.textContent;
                downloadPhotoBtn.textContent = "RENDERING...";
                downloadPhotoBtn.disabled = true;

                try {
                    await new Promise(r => setTimeout(r, 200));

                    const canvas = await html2canvas(photoStage, {
                        backgroundColor: '#ffffff',
                        useCORS: true,
                        scale: 2
                    });

                    const link = document.createElement('a');
                    link.download = `${activeCollectionName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_manifest.png`;
                    link.href = canvas.toDataURL("image/png");
                    link.click();

                    showMessage("Manifest downloaded");
                } catch (err) {
                    console.error("Photo generation failed:", err);
                    showMessage("Render error â€” check console");
                    alert("Image generation failed. Check console for details.");
                } finally {
                    downloadPhotoBtn.textContent = btnOriginalText;
                    downloadPhotoBtn.disabled = false;
                }
            }


            // --- eBay View Functions ---
            function openEbayViewModal() {
                if (!activeCollectionName || !collections[activeCollectionName] || collections[activeCollectionName].length === 0) {
                    showMessage("Collection is empty");
                    return;
                }

                const collection = collections[activeCollectionName];
                ebayListContainer.innerHTML = '';
                ebaySelectAll.checked = false;

                // Sort for easier reading: Name, then Foil
                collection.sort((a,b) => a.name.localeCompare(b.name) || (a.isFoil - b.isFoil));

                collection.forEach(card => {
                    const foilText = card.isFoil ? '(Foil)' : '';

                    // Generate eBay Description String
                    let ebayString = `${card.quantity}x MTG ${card.set_name} ${card.name}`;
                    if (card.isFoil) ebayString += ' Foil';
                    ebayString += ` #${card.collector_number}`;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'checklist-item text-sm group';
                    itemDiv.innerHTML = `
                        <input type="checkbox" class="rounded mr-3" data-ebay-title="${ebayString}">
                        <span class="font-bold mr-2 text-slate-400 w-8 text-right font-mono">${card.quantity}x</span>
                        <span class="truncate text-slate-300 group-hover:text-slate-100 transition-colors">${card.name} <span class="text-amber-400 text-xs font-mono">${foilText}</span></span>
                    `;
                    ebayListContainer.appendChild(itemDiv);
                });

                ebayViewModal.classList.remove('hidden');
            }

            function copyEbayListToClipboard() {
                const checkboxes = ebayListContainer.querySelectorAll('input[type="checkbox"]:checked');
                if (checkboxes.length === 0) {
                    alert("Select at least one item.");
                    return;
                }

                let textToCopy = "";
                checkboxes.forEach(cb => {
                    textToCopy += cb.dataset.ebayTitle + "\n";
                });

                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalText = copyEbayBtn.textContent;
                    copyEbayBtn.textContent = "COPIED";
                    copyEbayBtn.classList.remove('bg-purple-600', 'hover:bg-purple-500');
                    copyEbayBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    setTimeout(() => {
                        copyEbayBtn.textContent = originalText;
                        copyEbayBtn.classList.add('bg-purple-600', 'hover:bg-purple-500');
                        copyEbayBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                });
            }


            // --- Import Modal Logic ---
            function openImportModal() {
                if (!activeCollectionName) {
                    showMessage("Select a collection first");
                    return;
                }
                importTextArea.value = '';
                importFileInput.value = '';
                importFileName.textContent = '';
                importStatus.textContent = '';
                importErrors.textContent = '';
                importModal.classList.remove('hidden');
            }

            async function processImport() {
                const text = importTextArea.value;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) {
                    importStatus.textContent = "No input data";
                    return;
                }

                processImportBtn.disabled = true;
                cancelImportBtn.disabled = true;
                importErrors.innerHTML = '';
                importStatus.textContent = "Parsing cards...";
                let errors = [];
                let successes = 0;

                // Parse all lines
                const parsed = [];
                for (const line of lines) {
                    if (!line.match(/^\d+\s*x?/)) continue;

                    let processedLine = line;
                    const isFoil = processedLine.toLowerCase().includes('(foil)');
                    if (isFoil) processedLine = processedLine.replace(/\(Foil\)/ig, '').trim();

                    const priceMatch = processedLine.match(/\s*-\s*\$[0-9.]+/);
                    if (priceMatch) processedLine = processedLine.substring(0, priceMatch.index).trim();

                    let setCode = null;
                    let collectorNumber = null;
                    const detailMatch = processedLine.match(/\(([^)]+)\)/);
                    if (detailMatch) {
                        const details = detailMatch[1];
                        const setMatch = details.match(/^([A-Za-z0-9]+)/);
                        if (setMatch) setCode = setMatch[1].toLowerCase();
                        const numMatch = details.match(/#([a-zA-Z0-9]+)/);
                        if (numMatch) collectorNumber = numMatch[1];
                        processedLine = processedLine.substring(0, detailMatch.index).trim();
                    }

                    const quantityMatch = processedLine.match(/^(\d+)\s*x?\s*/);
                    if (!quantityMatch) { errors.push(`Parse error: "${line}"`); continue; }

                    const quantity = parseInt(quantityMatch[1], 10);
                    const cardName = processedLine.substring(quantityMatch[0].length).trim();
                    if (!cardName) { errors.push(`Missing card name: "${line}"`); continue; }

                    parsed.push({ cardName, quantity, isFoil, setCode, collectorNumber, originalLine: line });
                }

                // Split into API-fetchable (has set+collector) and fallback (match against search results)
                const apiFetchable = parsed.filter(p => p.setCode && p.collectorNumber);
                const fallback = parsed.filter(p => !p.setCode || !p.collectorNumber);

                // Fetch cards from Scryfall Collection API in chunks of 75
                if (apiFetchable.length > 0) {
                    const chunks = [];
                    for (let i = 0; i < apiFetchable.length; i += 75) {
                        chunks.push(apiFetchable.slice(i, i + 75));
                    }

                    for (let ci = 0; ci < chunks.length; ci++) {
                        const chunk = chunks[ci];
                        importStatus.textContent = `Fetching cards from Scryfall... (batch ${ci + 1}/${chunks.length})`;

                        const identifiers = chunk.map(p => ({
                            set: p.setCode,
                            collector_number: p.collectorNumber
                        }));

                        try {
                            const resp = await fetch('https://api.scryfall.com/cards/collection', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ identifiers })
                            });

                            if (!resp.ok) throw new Error(`Scryfall API error: ${resp.status}`);
                            const data = await resp.json();

                            const fetchedCards = data.data || [];
                            const notFound = data.not_found || [];

                            // Match fetched cards back to parsed entries
                            for (const p of chunk) {
                                const card = fetchedCards.find(c =>
                                    c.set.toLowerCase() === p.setCode &&
                                    c.collector_number.toLowerCase() === p.collectorNumber.toLowerCase()
                                );
                                if (card) {
                                    addToInventory(card, p.quantity, p.isFoil);
                                    successes++;
                                } else {
                                    errors.push(`Not found: "${p.cardName}" (${p.setCode.toUpperCase()} #${p.collectorNumber})`);
                                }
                            }

                            // Respect Scryfall rate limit (100ms between requests)
                            if (ci < chunks.length - 1) await new Promise(r => setTimeout(r, 150));
                        } catch (err) {
                            for (const p of chunk) {
                                errors.push(`API error: "${p.cardName}" â€” ${err.message}`);
                            }
                        }
                    }
                }

                // Fallback: match against current search results
                for (const p of fallback) {
                    let foundCard;
                    if (p.collectorNumber) {
                        foundCard = currentSearchResults.find(card =>
                            card.name.toLowerCase() === p.cardName.toLowerCase() &&
                            card.collector_number.toLowerCase() === p.collectorNumber.toLowerCase()
                        );
                    } else {
                        foundCard = currentSearchResults.find(card =>
                            card.name.toLowerCase() === p.cardName.toLowerCase()
                        );
                    }

                    if (foundCard) {
                        addToInventory(foundCard, p.quantity, p.isFoil);
                        successes++;
                    } else {
                        errors.push(`Not found: "${p.cardName}" (no set info â€” search a set first)`);
                    }
                }

                importStatus.textContent = `Import complete. ${successes} cards added.`;
                if (errors.length > 0) {
                    importErrors.innerHTML = `<strong>Errors (${errors.length}):</strong><br>` + errors.join('<br>');
                }

                updateInventoryDisplay();
                filterAndSortAndDisplayResults();

                setTimeout(() => {
                    importModal.classList.add('hidden');
                    processImportBtn.disabled = false;
                    cancelImportBtn.disabled = false;
                }, 3500);
            }

        });
    </script>
</body>
</html>
